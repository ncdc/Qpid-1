<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE bookinfo PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>

<!--
 
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at
 
   http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 
-->


<chapter id="high-level-client-api">
  <title>Apache Qpid Messaging API</title>

  <para>Apache Qpid is a reliable, asynchronous messaging system that
  supports the AMQP messaging protocol in several common programming
  languages on the Linux, Windows, Java, and Unix platforms. On the
  Java platform, Qpid uses the established <ulink
  url="http://java.sun.com/products/jms/">Java JMS API</ulink>. On the
  .NET platform, Qpid uses a <ulink
  url="http://qpid.apache.org/wcf.html">WCF binding</ulink>. For
  Python and C++, Qpid uses the Qpid Messaging API, which has
  implementations in both languages. Support for this API in Ruby will
  be added soon<footnote><para>Ruby currently uses an API that is
  closely tied to the AMQP version.</para></footnote>.</para>


  <para>Unlike earlier Qpid APIs, the Qpid Messaging API does not
  expose the details of the underlying messaging protocol or the
  software components defined by the protocol. Instead, it defines a
  declarative syntax for addressing messaging components; to use it
  with a given messaging protocol, a protocol mapping must be defined.
  This specification provides a mapping to AMQP 0-10.</para>

  <para>Qpid uses the same addressing scheme in Java JMS, WCF, and the
  Qpid Messaging API. An <emphasis>address</emphasis> is a simple
  string that represents the name of a node on a messaging broker. In
  the AMQP 0-10 mapping, an address resolves to an exchange or a
  queue.</para>


  <para>Here are the most important classes in the Qpid Messaging API
  programming model.
  </para>

  <itemizedlist>

<!--
TODO: Add definition for message
-->
    <listitem><para>A <emphasis>connection</emphasis> represents a
    network connection. The parameters for the network connection are
    specified using a URL-based syntax when the connection is
    opened.</para></listitem>

    <listitem><para>A <emphasis>session</emphasis> represents the
    interface between a <emphasis>messaging client</emphasis> and a
    <emphasis>messaging broker</emphasis>. A session is created by a
    connection.</para></listitem>

    <listitem><para>A <emphasis>message</emphasis> consists of
    <emphasis>message content</emphasis> (the body of the message),
    and <emphasis>message properties</emphasis>, which may include a
    subject, a reply address, etc. Message content is a blob which may
    contain text or binary data. Map messages allow binary data to be
    exchanged portably across languages and
    platforms.</para></listitem>

    <listitem><para>A <emphasis>sender</emphasis> is a messaging
    client that sends <emphasis>message</emphasis>s to a destination
    on a <emphasis>messaging broker</emphasis>. A sender is created by
    a session.</para></listitem>

    <listitem><para>A <emphasis>receiver</emphasis> is a messaging
    client that receives <emphasis>message</emphasis>s from a
    source on a <emphasis>Messaging Broker</emphasis>. A Receiver
    is created by a Session.</para></listitem>

  </itemizedlist>

  <section>
    <title>A Simple Messaging Program in C++</title>

    <para>The following program shows how to create a Connection,
    create a Session, send messages to a queue using a Sender, and
    receive messages from a queue using a Receiver.</para>

<programlisting><![CDATA[
#include <qpid/messaging/Connection.h>
#include <qpid/messaging/Message.h>
#include <qpid/messaging/Receiver.h>
#include <qpid/messaging/Sender.h>
#include <qpid/messaging/Session.h>

#include <iostream>

using namespace qpid::messaging;

int main(int argc, char** argv) {
    std::string broker = argc > 1 ? argv[1] : "localhost:5672";
    std::string address = argc > 2 ? argv[2] : "amq.topic";
    Connection connection(broker);
    try {
        connection.open();
        Session session = connection.createSession();

        Receiver receiver = session.createReceiver(address);
        Sender sender = session.createSender(address);

        sender.send(Message("Hello world!"));

        Message message = receiver.fetch(Duration::SECOND * 1);
        std::cout << message.getContent() << std::endl;
        session.acknowledge();
        
        connection.close();
        return 0;
    } catch(const std::exception& error) {
        std::cerr << error.what() << std::endl;
        connection.close();
        return 1;   
    }
}]]></programlisting>

  <para>##########################</para>

  </section>

  <section>
    <title>A Simple Messaging Program in Python</title>

    <programlisting><![CDATA[
import sys
from qpid.messaging import *

broker =  "localhost:5672" if len(sys.argv)<2 else sys.argv[1]
address = "amq.topic" if len(sys.argv)<3 else sys.argv[2]

connection = Connection(broker)

try:
  connection.open()
  session = connection.session()

  sender = session.sender(address)
  receiver = session.receiver(address)

  sender.send(Message("Hello world!"));

  message = receiver.fetch(timeout=1)
  print message.content
  session.acknowledge() # acknowledge message receipt

except MessagingError,m:
  print m
finally:
  connection.close()
]]></programlisting>

  <para>##########################</para>

  </section>

  <section>
    <title>A Simple Messaging Program in Java JMS</title>
    <programlisting><![CDATA[
]]></programlisting>

  </section>

  <section>
    <title>Address Strings</title>

    <para>As we have seen, an address is a string that identifies
    objects on the messaging broker. An <firstterm>address</firstterm>
    is simply a name.</para>

    <para>An <firstterm>address string</firstterm> can also have a
    <firstterm>subject</firstterm> and
    <firstterm>options</firstterm>.</para>

    <para>The syntax for an address string is:</para>

<programlisting><![CDATA[
address_string ::=  <adress> [ / <subject> ] [ ; <options> ]
options ::=  { <key> : <value>, ... }
]]></programlisting>

    <para>Addresses, subjects, and keys are strings.</para>

    <para>Values can be numbers, strings (with optional single or double quotes), maps, or lists.</para>

    <para>In most cases, queues, bindings, and exchanges are
    configured externally with management tools. Qpid Messaging API
    clients send to and receive from these queues and exchanges.</para>

    <para>In AMQP 0-10, messages are sent to exchanges, and received
    from queues. The Qpid Messaging API allows programs to
    send to or receive from any node. To make this possible, the
    mapping defines the semantics of sending and receiving for all
    AMQP 0-10 exchange types and queues as follows:

    <itemizedlist>
      <listitem><para>When a Sender sends a message to an exchange,
      the transfer destination is set to the exchange name, and the
      routing key is set to the value of the address string's
      subject.</para></listitem>
      <listitem><para>When a Receiver receives messages from an
      exchange, the API automatically creates a subscription queue and
      binds it to the exchange. If the address string contains a subject,
      then it is used as the binding key. If the address string does not
      contain a subject, then the binding key depends on the exchange
      type:
      <itemizedlist>
	<listitem><para>topic exchange: wildcard match</para></listitem>
	<listitem><para>direct exchange: error &mdash; the address string must specify a subject</para></listitem>
	<listitem><para>fanout: none</para></listitem>
	</itemizedlist></para>
	<para>The subscription queue's <varname>durability</varname>
	and <varname>autodelete</varname> properties can be set
	using options.</para>
      </listitem>
      <listitem><para>When a Sender sends a message to a queue, the
      message is sent to the AQMP 0-10 default queue, using the name
      of the queue as the routing key.</para></listitem>
      <listitem><para>When a Receiver receives messages from a queue,
      it is treated as a normal AMQP 0-10 queue subscription. The
      <varname>accept-mode</varname> property can be set using
      options.</para></listitem>
    </itemizedlist>
    </para>

    <para>The following sections describe the various kinds of
    address strings in detail. The examples in these sections use the
    <command>qpid-config</command> utility to configure AMQP 0-10
    queues and exchanges, send messages using
    <command>drain</command>, and receive messages using
    <command>spout</command>. The source code for
    <command>drain</command> and <command>spout</command> is available
    in both C++ and Python, and can be found in the examples directory
    for each language. These programs can use any address string as a source
    or a destination, and have many command line options to configure
    behavior&mdash;use the <command>-h</command> option for
    documentation on these options.</para>


    <section>
      <title>Simple Address Strings</title>

    <para>If an address string contains only a name, it is the address
    of a named node. On AMQP 0-10, a named node maps to a queue or an
    exchange with the same name.
    <note>
      <para>Address resolution is not yet well-defined if a queue and
      an exchange have the same name. This is a known problem, and is
      being resolved.</para>
    </note></para>

    <example>
      <title>Simple Address Strings</title>

      <para>Create a queue with qpid-config, send a message using
      spout, and read it using drain:</para>

      <screen>
$ qpid-config add queue hello-world
$ ./spout -a hello-world
$ ./drain -a hello-world

Message(properties={spout-id:c877e622-d57b-4df2-bf3e-6014c68da0ea:0}, content='')
      </screen>

      <para>Exchanges and queues are addressed in exactly the same way
      in the Qpid Messaging API. If we delete the queue named
      <literal>hello-world</literal> and create an exchange with the
      same name, we can write to and read from the exchange in the
      same way as for the queue:</para>

      <screen>
$ qpid-config del queue hello-world
$ qpid-config add exchange topic hello-world
$ ./spout -a hello-world
$ ./drain -a hello-world
$
      </screen>

      <para>However, in AMQP 0-10, exchanges discard messages if no
      queue is bound to the exchange, unlike queues, which store
      messages until they are retrieved.  Because of this, no messages
      were output in the above screen. If <command>drain</command> is
      called before <command>spout</command>, a Receiver is created
      for the exchange, which also creates a subscription queue and a
      binding. Run <command>drain</command> in one terminal window
      using <literal>-t</literal> to specify a timeout in seconds, and
      run <command>spout</command> in another window to send a message
      for <command>drain</command> to receive.</para>

      
      
      <para><emphasis>First Window:</emphasis></para>

      <screen>
$ ./drain -a hello-word -t 30
      </screen>
      

      <para><emphasis>Second Window:</emphasis></para>

      <screen>
$ ./spout -a hello-word
      </screen>

      <para>Once <command>spout</command> has sent a message, return
      to the first window to see the output from
      <command>drain</command>:</para>

      <screen>
Message(properties={spout-id:7da2d27d-93e6-4803-8a61-536d87b8d93f:0}, content='')
      </screen>

      <para>You can run <command>drain</command> in several separate
      windows; each will create a subscription for the exchange, and
      each will receive all messages sent to the exchange.</para>

    </example>
    </section>
    
    <section>
      <title>Subjects</title>
      <para>Subjects are used to classify messages.</para>

      <para>A Sender's subject is assigned to each message that it
      sends (this can be overridden by specifying a subject directly
      on the message). In the AMQP 0-10 mapping, the message's subject
      is used as the routing key for all messages sent to the
      messaging broker. If a Sender is bound to an AMQP 0-10 exchange,
      it sends messages to that exchange. If a Sender is bound to an
      AMQP 0-10 queue, the message is sent to the default
      exchange.</para>

      <para>A Receiver's subject is used to filter messages; only
      messages with a subject that matches the Receiver's subject will
      be received. If a Receiver's name resolves to an AMQP 0-10
      exchange, the subject is used as a binding key for the
      corresponding AMQP 0-10 exchange type.
      </para>

      <note>
	<para>The C++ implementation of the Qpid messaging broker does
	not currently support selectors, so a Receiver's subject does
	not filter messages if the Receiver's address resolves to a
	queue.</para>
      </note>

      <section>
	  <title>Direct Exchanges</title>

	  <para>In an AMQP 0-10 direct exchange, messages are routed
	  to queues if the routing key exactly matches the binding
	  key. In the Qpid Messaging API, if a Sender and a
	  Receiver are bound to the same exchange, the Receiver will
	  receive messages if the Sender's subject matches the
	  Receiver's subject.</para>

	  <para>Let's create a direct exchange and listen for messages
	  whose subject is <literal>sports</literal>:</para>

	  <para><emphasis>First Window:</emphasis></para>
	  <screen>
$ qpid-config add exchange direct direct-exchange
$ ./drain -a direct-exchange/sports -t 30
	  </screen>

	  <para>In a second window, let's send messages to the
	  exchange we created:</para>

	  <para><emphasis>Second Window:</emphasis></para>
	  <screen>
$ ./spout -a direct-exchange/sports
$ ./spout -a direct-exchange/news
	  </screen>

	  <para>Now look at the first window, and you will see the
	  message with the subject <literal>sports</literal> has been
	  received, but not the message with the subject
	  <literal>news</literal>:</para>

	  <screen>
Message(properties={qpid.subject:sports, spout-id:9441674e-a157-4780-a78e-f7ccea998291:0}, content='')
	  </screen>

	  <para>If you run <command>drain</command> in multiple
	  windows using the same subject, all instances of
	  <command>drain</command> receive the messages for that
	  subject.</para>

      </section>
      <section>
	  <title>Topic Exchanges</title>

	  <para>An AMQP 0-10 topic exchange uses routing keys that
	  contain multiple words separated by a <quote>.</quote>
	  delimiter. For instance, in a news application, a Sender's
	  subject might be <literal>usa.news</literal>,
	  <literal>usa.weather</literal>,
	  <literal>europe.news</literal>, or
	  <literal>europe.weather</literal>. A Receiver's subject can
	  include wildcard characters&mdash; <quote>#</quote> matches
	  one or more words in the message's subject, <quote>*</quote>
	  matches a single word. For instance, if the Receiver's
	  subject is <literal>*.news</literal>, it matches messages
	  with the subject <literal>europe.news</literal> or
	  <literal>usa.news</literal>; if the Receiver's subject is
	  <literal>europe.#</literal>, it matches messages with
	  subjects like <literal>europe.news</literal> or
	  <literal>europe.pseudo.news</literal>.</para>

	  <para>Let's create a topic exchange and listen for messages
	  whose subject is <literal>news</literal>:</para>

	  <para><emphasis>First Window:</emphasis></para>

	  <screen>
$ qpid-config add exchange topic topic-exchange
$ ./drain -a topic-exchange/news -t 30
          </screen>

	  <para>In a second window, let's send messages to the
	  exchange we created:</para>

	  <para><emphasis>Second Window:</emphasis></para>
	  <screen>
$ ./spout -a topic-exchange/news
$ ./spout -a topic-exchange/sports
	  </screen>


	  <para>Now look at the first window, and you will see the
	  message with the subject <literal>news</literal> has been
	  received, but not the message with the subject
	  <literal>sports</literal>:</para>

	  <screen>
Message(properties={qpid.subject:news, spout-id:bafefb74-c5be-4a8b-9e4b-45f7a855e250:0}, content='')
	  </screen>


	  <para>Now let's use the topic exchange with wildcards in the
	  Receiver and multi-word keys in the Sender. This time, let's
	  use two-word keys. The Receiver uses the subject
	  <literal>*.news</literal> to listen for messages in which
	  the second word of the key is
	  <literal>news</literal>:</para>


	  <para><emphasis>First Window:</emphasis></para>

	  <screen>
$ ./drain -a topic-exchange/*.news -t 30
	  </screen>

	  <para>Now let's send messages using several different
	  two-word keys:</para>

	  <para><emphasis>Second Window:</emphasis></para>

	  <screen>
$ ./spout -a topic-exchange/usa.news
$ ./spout -a topic-exchange/usa.sports
$ ./spout -a topic-exchange/europe.sports
$ ./spout -a topic-exchange/europe.news
$ 
	  </screen>

	  <para>Now look at the first window, and you will see the
	  messages with <literal>news</literal> in the second word of
	  the key have been received:</para>

	  <screen>
Message(properties={qpid.subject:usa.news, spout-id:73fc8058-5af6-407c-9166-b49a9076097a:0}, content='')
Message(properties={qpid.subject:europe.news, spout-id:f72815aa-7be4-4944-99fd-c64c9747a876:0}, content='')
	  </screen>

	  <para>Finally, let's use the <literal>#</literal> wildcard
	  in the Receiver to match any number of words in the key. The
	  Receiver uses the key <literal>#.news</literal> to listen
	  for messages in which the last word of the key is
	  <literal>news</literal>, no matter how many words are in the
	  key:</para>

	  <para><emphasis>First Window:</emphasis></para>

	  <screen>
$ ./drain -a topic-exchange/#.news -t 30
	  </screen>

	  <para>Now let's send messages using a variety of different
	  multi-word keys:</para>

	  <para><emphasis>Second Window:</emphasis></para>

	  <screen>
$ ./spout -a topic-exchange/news
$ ./spout -a topic-exchange/sports
$ ./spout -a topic-exchange/usa.news
$ ./spout -a topic-exchange/usa.sports
$ ./spout -a topic-exchange/usa.faux.news
$ ./spout -a topic-exchange/usa.faux.sports
	  </screen>

	  <para>Now look at the first window, and you will see the
	  messages with <literal>news</literal> in the last word of
	  the key have been received:</para>

	  <screen>
Message(properties={qpid.subject:news, spout-id:cbd42b0f-c87b-4088-8206-26d7627c9640:0}, content='')
Message(properties={qpid.subject:usa.news, spout-id:234a78d7-daeb-4826-90e1-1c6540781eac:0}, content='')
Message(properties={qpid.subject:usa.faux.news, spout-id:6029430a-cfcb-4700-8e9b-cbe4a81fca5f:0}, content='')
	  </screen>

	</section>

	<section>
	  <title>Fanout Exchanges</title>

	  <para>A fanout exchange ignores the subject, and no
	  filtering is done.</para>

	  <para>Let's create a fanout exchange and listen for
	  messages.  We will use the subject <literal>news</literal>
	  in the Receiver to demonstrate that this subject is not
	  actually used to filter messages:</para>


	  <para><emphasis>First Window:</emphasis></para>

	  <screen>
$ qpid-config add exchange fanout fanout-exchange
$ ./drain -a fanout-exchange/news -t 30
	  </screen>

	  <para>Now let's send a message using a different
	  subject:</para>

	  <para><emphasis>Second Window:</emphasis></para>

	  <screen>
$ ./spout -a fanout-exchange/sports
	  </screen>

	  <para>Returning to the first window, we see that the message
	  was received even though the Receiver's subject was
	  different from the Sender's subject:</para>

	  <screen>
Message(properties={qpid.subject:sports, spout-id:931399a1-27fc-471c-8dbe-3048260f9441:0}, content='')
	  </screen>

	  <para>This happens because of the routing semantics of the AMQP 0-10 fanout exchange.</para>

	</section>

	</section>
	<section>
	  <title>Queues</title>

	  <para>If a Sender is bound to a queue, its messages are sent
	  to the default exchange using the queue's name as the
	  routing key. If a Receiver is bound to a queue, it receives
	  messages from the queue.</para>

	  <para>Let's create a queue and listen for messages on it.</para>

	  <para><emphasis>First Window:</emphasis></para>

	  <screen>
$ ./qpid-config add queue amqp010-queue
$ ./drain -a amqp010-queue -t 30
	  </screen>

	  <para>Now let's send some messages. The subject is not used for routing purposes.</para>
	  <screen>
$ ./spout -a amqp010-queue/news
$ ./spout -a amqp010-queue
	  </screen>

	  <para>Now look at the first window, and you will see that
	  both messages have been received:</para>

	  <screen>
Message(properties={qpid.subject:news, spout-id:6c769437-60be-4bc0-9bf6-5a77cb6ba65f:0}, content='')
Message(properties={spout-id:c8ab5013-a19e-4f54-967c-797c8ad6568b:0}, content='')
	  </screen>

	</section>


	<!-- ### match exchange? -->

	<section>
	  <title>Custom Exchanges</title>
	
	  <para>AMQP 0-10 also supports custom exchanges. The
	  Qpid messaging broker includes the XML Exchange, which uses an
	  XQuery to filter messages based on message properties and XML
	  message content.</para>

<!-- ### Do drain / spout support the XML Exchange? -->

	</section>

    </section>


    <section>
      <title>Extended Address Options</title>

      <para>Extended Address Options are parameters that affect the behavior of Senders and Receivers.</para>

      <para>Some of these options specify aspects of the resolution process; for instance, they may make assertions that must be satisfied in order for resolution to succeed, or they may state that the node should be created if it does not already exist.</para>

      <para>Let's use <command>drain</command> and <command>spout</command> to show how this works. First, let's use the <literal>assert</literal> option to insist that an address must resolve to a queue.  In the Qpid Messaging API, a node is either a queue or a topic. A queue is used the same way as in AMQP 0-10, a topic node is the same thing AMQP 0-10 calls an exchange. (In this section, we will use the term <quote>topic node</quote> for a Qpid Messaging API topic node, and <quote>AMQP 0-10 topic exchange</quote> for the exchange type that has the same name.) </para>

      <para>AMQP 0-10 has several built-in exchanges that are predeclared: <literal>amq.topic</literal>, <literal>amq.direct</literal>, <literal>amq.match</literal>, and <literal>amq.fanout</literal>. In the Qpid Messaging API, any of these exchanges is considered a topic node. Let's use <command>drain</command>, and assert that  <literal>amq.fanout</literal> is a topic node:</para>

      <screen>$ ./drain -a "amq.fanout; { assert: always, node: { type: topic }}"</screen>

      <para>The address resolves succesfully. No exception is raised, because a topic node named <literal>amq.fanout</literal> exists. Now let's assert that <literal>amq.fanout</literal> is a queue node:</para>

      <screen>$ ./drain -a "amq.fanout; { assert: always, node: { type: queue }}"
2010-04-09 14:01:35 warning Exception received from broker: not-found: not-found: Queue not found: amq.fanout (qpid/broker/SessionAdapter.cpp:753) [caused by 0 \x08:\x01]
Queue amq.fanout does not exist</screen>

      <para>An exception was raised because there is no queue named <literal>amq.fanout</literal>, so address resolution failed.</para>


      <para>Now let's use the <literal>create</literal> option with <command>drain</command>, telling it to create the queue <literal>xoxox</literal> if it does not already exist:</para>

      <para><emphasis>First Window:</emphasis></para>
      <screen>$ ./drain -a "xoxox ; {create: always}" -t 30</screen>

      <para>In previous examples, we created the queue before listening for messages on it. Using <literal>create: always</literal>, the queue is automatically created if it does not exist. Now we can send messages to this queue:</para>

      <para><emphasis>Second Window:</emphasis></para>
      <screen>$ ./drain -a "xoxox ; {create: always}" -t 30</screen>

      <para>Returning to the first window, we see that <command>drain</command> has received this message:</para>

      <screen>Message(properties={spout-id:1a1a3842-1a8b-4f88-8940-b4096e615a7d:0}, content='')</screen>

<!--
TODO: Add some x-declare, x-subscribe, link, x-bindings examples
-->


      <para>Other options specify message transfer semantics; for instance, they may state whether messages should be consumed or read in browsing mode, or specify reliability characteristics. For instance, we can use browse mode to receive messages without removing them from the queue, thus allowing other Readers to receive them:</para>

      <screen>
$ ./drain 'hello-queue; {mode: browse}'
      </screen>

<!--
TODO: Add some reliability option examples
-->

      <table>
	<title>Extended Address Options</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>option</entry>
	      <entry>parameters</entry>
	      <entry>semantics</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>
		assert
	      </entry>
	      <entry>
		node
	      </entry>
	      <entry>
		Asserts that the node properties are satisfied for a
		node. If they are not, node resolution fails and an
		exception is raised. <!-- ### Which exception -->
	      </entry>
	    </row>

	    <row>
	      <entry>
		create
	      </entry>
	      <entry>
		node (optional)
	      </entry>
	      <entry>
		Creates the node if it does not exist. No error is raised if the node does exist.
	      </entry>
	    </row>
	    <row>
	      <entry>
		delete
	      </entry>
	      <entry>
		N/A
	      </entry>
	      <entry>
		Delete the node when the Sender or Receiver is closed.
	      </entry>
	    </row>
	    <row>
	      <entry>
		reliability
	      </entry>
	      <entry>
		unreliable, at-least-once, at-most-once, exactly-once
	      </entry>
	      <entry>
	      </entry>
	    </row>
	    <row>
	      <entry>
		mode
	      </entry>
	      <entry>
		browse, consume
	      </entry>
	      <entry>
	      </entry>
	    </row>
	    <row>
	      <entry>
		reconnect
	      </entry>
	      <entry>
	        True, False
	      </entry>
	      <entry>
		Transparently reconnect if the connection is lost.
	      </entry>
	    </row>
	    <row>
	      <entry>
		reconnect_timeout
	      </entry>
	      <entry>
		N
	      </entry>
	      <entry>
		Total number of seconds to continue reconnection attempts before giving up and raising an exception.
	      </entry>
	    </row>
	    <row>
	      <entry>
		reconnect_limit
	      </entry>
	      <entry>
		N
	      </entry>
	      <entry>
		Maximum number of reconnection attempts before giving up and raising an exception.
	      </entry>
	    </row>
	    <row>
	      <entry>
		reconnect_interval_min
	      </entry>
	      <entry>
		N
	      </entry>
	      <entry>
		Minimum number of seconds between reconnection attempts. The first reconnection attempt is made immediately; if that fails, the first reconnection delay is set to the value of <literal>reconnect_interval_min</literal>; if that attempt fails, the reconnection interval increases exponentially until a reconnection attempt succeeds or <literal>reconnect_interval_max</literal> is reached.
	      </entry>
	    </row>
	    <row>
	      <entry>
		reconnect_interval_max
	      </entry>
	      <entry>
		N
	      </entry>
	      <entry>
		Maximum reconnection interval.
	      </entry>
	    </row>
	    <row>
	      <entry>
		reconnection_interval
	      </entry>
	      <entry>
		N
	      </entry>
	      <entry>
		Sets both <literal>reconnection_interval_min</literal> and <literal>reconnection_interval_max</literal> to the same value.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>


      <table>
	<title>Node Properties</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>property</entry>
	      <entry>parameters</entry>
	      <entry>semantics</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>
		type
	      </entry>
	      <entry>
		topic, queue
	      </entry>
	      <entry>
	      </entry>
	    </row>
	    <row>
	      <entry>
		durable
	      </entry>	       
	      <entry>
		True, False
	      </entry>
	      <entry>
	      </entry>
	    </row>
	    <row>
	      <entry>
		x-declare
	      </entry>
	      <entry>
		unrestricted map
	      </entry>
	      <entry>
                If the property is defined in the underlying protocol (AMQP 0-10), the values and semantics are defined by the protocol. Otherwise, values are added to the arguments map used to declare topics<footnote><para>The Qpid Messaging API, like Java JMS, uses the term topic to refer to what AMQP 0-10 calls an exchange. One kind of AMQP 0-10 exchange is called a topic exchange, that is not what is meant here.</para></footnote> or queues.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>



     <table>
	<title>x-declare properties for AMQP 0-10</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>property</entry>
	      <entry>parameters</entry>
	      <entry>semantics</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>
		type
	      </entry>
	      <entry>
		direct, topic, fanout, header, xml
	      </entry>
	      <entry>
                The AMQP 0-10 exchange type. 		
	      </entry>
	    </row>
	    <row>
	      <entry>
		bindings
	      </entry>
	      <entry>
		["exchange/binding-key", ... ] 
	      </entry>
	      <entry>
		This property is used to create bindings for queues. If the Address does not resolve to a queue, an error is raised. 
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
     </table>


  </section>


  <section>
    <title>Messaging Properties</title>

    <para>This section shows how Qpid Messaging API message
    properties are mapped to AMQP message properties and delivery
    properties.</para>

    <para>Request-response applications frequently use a reply-to property to tell a server where to send a response. The following code shows how a server extracts the reply-to property and uses it to set the address to respond to a client.</para>

    <programlisting>
            Message request = receiver.fetch();
            const Address&amp; address = request.getReplyTo(); <lineannotation>Get "reply-to" field from request ...</lineannotation>
            if (address) {
                Sender sender = session.createSender(address); <lineannotation>... and use it as the address to send response</lineannotation>
                std::string s = request.getContent();
                std::transform(s.begin(), s.end(), s.begin(), toupper);
                Message response(s);
                sender.send(response);
                std::cout &lt;&lt; "Processed request: "
                          &lt;&lt; request.getContent()
                          &lt;&lt; " -> "
                          &lt;&lt; response.getContent() &lt;&lt; std::endl;
                session.acknowledge();
    </programlisting>

    <para>In the following table, <varname>msg</varname> refers to the
    Message class defined in the Qpid Messaging API,
    <varname>mp</varname> refers to an AMQP 0-10
    <varname>message-properties</varname> struct, and
    <varname>dp</varname> refers to an AMQP 0-10
    <varname>delivery-properties</varname> struct.</para>

     <table>
       <title>Mapping to AMQP 0-10 Message Properties</title>
       <tgroup cols="3">
	 <thead>
	   <row>
	     <entry>Python API</entry>
	     <entry>C++ API</entry>
	     <entry>AMQP 0-10 Property</entry>
	   </row>
	 </thead>
	 <tbody>
	   <row>
	     <entry>msg.id</entry><entry>msg.{get,set}MessageId()</entry><entry>mp.message_id</entry>
	   </row>
	   <row>
	     <entry>msg.to</entry><entry>- -</entry><entry>mp.application_headers["qpid.to"]</entry>
	   </row>
	   <row>
	     <entry>msg.subject</entry><entry>msg.{get,set}Subject()</entry><entry>mp.application_headers["qpid.subject"]</entry>
	   </row>
	   <row>
	     <entry>msg.user_id</entry><entry>msg.{get,set}UserId()</entry><entry>mp.user_id</entry>
	   </row>
	   <row>
	     <entry>msg.reply_to</entry><entry>msg.{get,set}ReplyTo()</entry><entry>mp.reply_to<footnote><para>The reply_to is converted from the protocol representation into an address.</para></footnote></entry>
	   </row>
	   <row>
	     <entry>msg.correlation_id</entry><entry>msg.{get,set}CorrelationId()</entry><entry>mp.correlation_id</entry>
	   </row>
	   <row>
	     <entry>msg.durable</entry><entry>msg.{get,set}Durable()</entry><entry>dp.delivery_mode == delivery_mode.persistent<footnote><para>Note that msg.durable is a boolean, not an enum.</para></footnote></entry>
	   </row>
	   <row>
	     <entry>msg.priority</entry><entry>msg.{get,set}Priority()</entry><entry>dp.priority</entry>
	   </row>
	   <row>
	     <entry>msg.ttl</entry><entry>msg.{get,set}Ttl()</entry><entry>dp.ttl</entry>
	   </row>
	   <row>
	     <entry>msg.redelivered</entry><entry>msg.isRedelivered()</entry><entry>dp.redelivered</entry>
	   </row>
	   <row><entry>msg.properties</entry><entry>msg.{get,set}Headers()</entry><entry>mp.application_headers</entry>
	   </row>
	   <row>
	     <entry>msg.content_type</entry><entry>msg.{get,set}ContentType()</entry><entry>mp.content_type</entry>
	   </row>
	 </tbody>
       </tgroup>
     </table>

<!--
Examples - do client / server, pub-sub here...
-->

  </section>
</chapter>

<!--
     - client code remains exactly the same, but routing behavior
       changes
     - exchanges drop messages if nobody is listening, so we need to
       start drain first
     - drain will exit immediately if the source is empty (note that
       this is actually a semantic guarantee provided by the API, we
       know for a fact that the source is empty when drain/fetch
       reports it, no fudge factor timeout is required [this assumes
       nobody is concurrently publishing of course])
     - drain -f invokes blocking fetch (you could use a timeout here also)
-->
