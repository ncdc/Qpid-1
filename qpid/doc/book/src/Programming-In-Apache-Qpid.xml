<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
]>

<!--
   
   Licensed to the Apache Software Foundation (ASF) under one
   or more contributor license agreements.  See the NOTICE file
   distributed with this work for additional information
   regarding copyright ownership.  The ASF licenses this file
   to you under the Apache License, Version 2.0 (the
   "License"); you may not use this file except in compliance
   with the License.  You may obtain a copy of the License at
   
   http://www.apache.org/licenses/LICENSE-2.0
   
   Unless required by applicable law or agreed to in writing,
   software distributed under the License is distributed on an
   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
   KIND, either express or implied.  See the License for the
   specific language governing permissions and limitations
   under the License.
   
  -->

<book id="client-api-tutorial">
  <title>Programming in Apache Qpid</title>
  <subtitle>Cross-Platform AMQP Messaging in Java JMS, .NET, C++, and Python</subtitle>

  <chapter>
    <title>Introduction</title>
    
    <para>Apache Qpid is a reliable, asynchronous messaging system that
      supports the AMQP messaging protocol in several common programming
      languages. Qpid is supported on most common platforms.
    </para>

    <itemizedlist>
      <listitem>
        <para>
          On the Java platform, Qpid uses the
          established <ulink url="http://java.sun.com/products/jms/">Java JMS
            API</ulink>. 
        </para>
      </listitem>
      <listitem>
        <para>
          On the .NET platform, Qpid defines
          a <ulink url="http://qpid.apache.org/wcf.html">WCF
            binding</ulink>.
        </para>
      </listitem>
      <listitem>
        <para>
          For Python and C++, Qpid defines its own messaging API, the
          <firstterm>Qpid Messaging API</firstterm>, which is
          conceptually similar in each supported language.
        </para>
      </listitem>
      <listitem>
        <para>
          Support for this API in Ruby will be added
          soon (Ruby currently uses an API that is closely
	  tied to the AMQP version).
        </para>
      </listitem>
    </itemizedlist>
  </chapter>

  <chapter>
    <title>Using the Qpid Messaging API</title>

    <para>The Qpid Messaging API is quite simple, consisting of only a
      handful of core classes.
    </para>

    <itemizedlist>

      <listitem>
        <para>
          A <firstterm>message</firstterm> consists of a standard set
          of fields (e.g. <literal>subject</literal>,
          <literal>reply-to</literal>), an application-defined set of
          properties, and message content (the main body of the
          message).
        </para>
      </listitem>
      
      <listitem>
        <para>
          A <firstterm>connection</firstterm> represents a network
          connection to a remote endpoint.
        </para>
      </listitem>
      
      <listitem>
        <para>
          A <firstterm>session</firstterm> provides a sequentially
          ordered context for sending and receiving
          <emphasis>messages</emphasis>. A session is obtained from a
          connection.
        </para>
      </listitem>
      
      <listitem>
        <para>
	  A <firstterm>sender</firstterm> sends messages to a target
	  using the <literal>sender.send</literal> method. A sender is
	  obtained from a session for a given target address.
        </para>
      </listitem>
      
      <listitem>
        <para>
	  A <firstterm>receiver</firstterm> receives messages from a
	  source using the <literal>receiver.fetch</literal> method.
	  A receiver is obtained from a session for a given source
	  address.
        </para>
      </listitem>
      
    </itemizedlist>

    <para>
      The following sections show how to use these classes in a
      simple messaging program.
    </para>

    <section>
      <title>A Simple Messaging Program in C++</title>

      <para>The following C++ program shows how to create a connection,
        create a session, send messages using a sender, and receive
        messages using a receiver.</para>

	<example>
	  <title>"Hello world!" in C++</title>
	  <programlisting lang="c++"><![CDATA[
#include <qpid/messaging/Connection.h>
#include <qpid/messaging/Message.h>
#include <qpid/messaging/Receiver.h>
#include <qpid/messaging/Sender.h>
#include <qpid/messaging/Session.h>

#include <iostream>]]>

using namespace qpid::messaging;

int main(int argc, char** argv) {
    std::string broker = argc > 1 ? argv[1] : "localhost:5672";
    std::string address = argc > 2 ? argv[2] : "amq.topic";
    Connection connection(broker); 
    try {
        connection.open();  <co id="hello-cpp-open" linkends="callout-cpp-open"/>
        Session session = connection.createSession(); <co id="hello-cpp-session" linkends="callout-cpp-session"/>

        Receiver receiver = session.createReceiver(address); <co id="hello-cpp-receiver" linkends="callout-cpp-receiver"/>
        Sender sender = session.createSender(address); <co id="hello-cpp-sender" linkends="callout-cpp-sender"/>

        sender.send(Message("Hello world!"));

        Message message = receiver.fetch(Duration::SECOND * 1); <co id="hello-cpp-fetch" linkends="callout-cpp-fetch"/>
        <![CDATA[std::cout << message.getContent() << std::endl;]]>
        session.acknowledge(); <co id="hello-cpp-acknowledge" linkends="callout-cpp-acknowledge"/>
        
        connection.close(); <co id="hello-cpp-close" linkends="callout-cpp-close"/>
        return 0;
    } catch(const std::exception&amp; error) {
        <![CDATA[std::cerr << error.what() << std::endl;]]>
        connection.close();
        return 1;   
    }
}</programlisting>

      <calloutlist>
	<callout id="callout-cpp-open" arearefs="hello-cpp-open">
	  <para>Establishes the connection with the messaging broker.</para>
	</callout>
	<callout id="callout-cpp-session" arearefs="hello-cpp-session">
	  <para>Creates a session object, which maintains the state of all interactions with the messaging broker, and manages senders and receivers.</para>
	</callout>
	<callout id="callout-cpp-receiver" arearefs="hello-cpp-receiver">
	  <para>Creates a receiver that reads from the given address.</para>
	</callout>
	<callout id="callout-cpp-sender" arearefs="hello-cpp-sender">
	  <para>Creates a sender that sends to the given address.</para>
	</callout>
	<callout id="callout-cpp-fetch" arearefs="hello-cpp-fetch">
	  <para>Reads the next message. The duration is optional, if omitted, will wait indefinitely for the next message.</para>
	</callout>
	<callout id="callout-cpp-acknowledge" arearefs="hello-cpp-acknowledge">
	  <para>Acknowledges messages that have been read. To guarantee delivery, a message remains on the messaging broker until it is acknowledged by a client. session.acknowledge() acknowledges all unacknowledged messages for the given session&mdash;this allows acknowledgements to be batched, which is  more efficient than acknowledging messages individually.</para>
	</callout>
	<callout id="callout-cpp-close" arearefs="hello-cpp-close">
	  <para>Closes the connection, all sessions managed by the connection, and all senders and receivers managed by each session.</para>
	</callout>
      </calloutlist>
      </example>


    </section>

    <section>
      <title>A Simple Messaging Program in Python</title>

      <para>The following Python program shows how to create a
        connection, create a session, send messages using a sender, and
        receive messages using a receiver.</para>

	<example>
	  <title>"Hello world!" in Python</title>
	  <programlisting lang="python"><![CDATA[
import sys
from qpid.messaging import *

broker =  "localhost:5672" if len(sys.argv)<2 else sys.argv[1]
address = "amq.topic" if len(sys.argv)<3 else sys.argv[2]]]>

connection = Connection(broker)

try:
  connection.open()  <co id="hello-python-open" linkends="callout-python-open"/>
  session = connection.session()   <co id="hello-python-session" linkends="callout-python-session"/>

  sender = session.sender(address)  <co id="hello-python-sender" linkends="callout-python-sender"/>
  receiver = session.receiver(address)  <co id="hello-python-receiver" linkends="callout-python-receiver"/>

  sender.send(Message("Hello world!"));

  message = receiver.fetch(timeout=1)  <co id="hello-python-fetch" linkends="callout-python-fetch"/>
  print message.content
  session.acknowledge() <co id="hello-python-acknowledge" linkends="callout-python-acknowledge"/>

except MessagingError,m:
  print m
finally:
  connection.close()  <co id="hello-python-close" linkends="callout-python-close"/>
</programlisting>

	  <calloutlist>
	    <callout id="callout-python-open" arearefs="hello-python-open">
	      <para>Establishes the connection with the messaging broker.</para>
	    </callout>
	    <callout id="callout-python-session" arearefs="hello-python-session">
	      <para>Creates a session object, which maintains the state of all interactions with the messaging broker, and manages senders and receivers.</para>
	    </callout>
	    <callout id="callout-python-receiver" arearefs="hello-python-receiver">
	      <para>Creates a receiver that reads from the given address.</para>
	    </callout>
	    <callout id="callout-python-sender" arearefs="hello-python-sender">
	      <para>Creates a sender that sends to the given address.</para>
	    </callout>
	    <callout id="callout-python-fetch" arearefs="hello-python-fetch">
	      <para>Reads the next message. The duration is optional, if omitted, will wait indefinitely for the next message.</para>
	    </callout>
	    <callout id="callout-python-acknowledge" arearefs="hello-python-acknowledge">
	      <para>Acknowledges messages that have been read. To guarantee delivery, a message remains on the messaging broker until it is acknowledged by a client. session.acknowledge() acknowledges all unacknowledged messages for the given session&mdash;this allows acknowledgements to be batched, which is  more efficient than acknowledging messages individually.</para>
	    </callout>
	    <callout id="callout-python-close" arearefs="hello-python-close">
	      <para>Closes the connection, all sessions managed by the connection, and all senders and receivers managed by each session.</para>
	    </callout>
	  </calloutlist>

	</example>

    </section>
    <section id="section-addresses">
      <title>Addresses</title>
      
      <para>An <firstterm>address</firstterm> is the name of a message
      target or message source. In the programs we have just seen, we
      used the address <literal>amq.topic</literal> (which is the name
      of an exchange on an AMQP 0-10 messaging broker).
      
      The methods that create senders and receivers require an
      address. The details of sending to a particular target or
      receiving from a particular source are then handled by the
      sender or receiver. A different target or source can be used
      simply by using a different address.
      </para>

      <para>An address resolves to a <firstterm>node</firstterm>. The
      Qpid Messaging API recognises two kinds of nodes,
      <firstterm>queues</firstterm> and <firstterm>topics</firstterm>

	   <footnote><para>The terms <emphasis>queue</emphasis> and
	   <emphasis>topic</emphasis> here were chosen to align with
	   their meaning in JMS. These two addressing 'patterns',
	   queue and topic, are sometimes refered as point-to-point
	   and publish-subscribe. AMQP 0-10 has an exchange type
	   called a <emphasis>topic exchange</emphasis>. When the term
	   <emphasis>topic</emphasis> occurs alone, it refers to a
	   Messaging API topic, not the topic
	   exchange.</para></footnote>.

      A queue stores each message until it has been received and
      acknowledged, and only one receiver can receive a given message
      <footnote><para>There are exceptions to this rule; for instance,
      a receiver can use <literal>browse</literal> mode, which leaves
      messages on the queue for other receivers to
      read.</para></footnote>

      A topic immediately delivers a message to all eligible
      receivers; if there are no eligible receivers, it discards the
      message.  In the AMQP 0-10 implementation of the API,
      
          <footnote><para>The AMQP 0-10 implementation is the only one
          that currently exists.</para></footnote>

      queues map to AMQP queues, and topics map to AMQP exchanges.

          <footnote><para>In AMQP 0-10, messages are sent to
          exchanges, and read from queues. The Messaging API also
          allows a sender to send messages to a queue; internally,
          Qpid implements this by sending the message to the default
          exchange, with the name of the queue as the routing key. The
          Messaging API also allows a receiver to receive messages
          from a topic; internally, Qpid implements this by setting up
          a private subscription queue for the receiver and binding
          the subscription queue to the exchange that corresponds to
          the topic.</para></footnote>
      </para>

      <para>In the rest of this tutorial, we present many examples
      using two programs that take an address as a command line
      parameter.  <command>spout</command> sends messages to the
      target address, <command>drain</command> receives messages from
      the source address.  The source code is available in both C++
      and Python, and can be found in the examples directory for each
      language. These programs can use any address string as a source
      or a destination, and have many command line options to
      configure behavior&mdash;use the <command>-h</command> option
      for documentation on these options. 

      <footnote><para>Currently, the Python and C++
      implementations of <command>drain</command> and
      <command>spout</command> have slightly different
      options. This tutorial uses the C++ implementation. The
      options will be reconciled in the near
      future.</para></footnote>


      The examples in this tutorial also use the
      <command>qpid-config</command> utility to configure AMQP 0-10
      queues and exchanges on a Qpid broker.
      </para>


      <example>
        <title>Queues</title>

        <para>Create a queue with <command>qpid-config</command>, send a message using
          <command>spout</command>, and read it using <command>drain</command>:</para>

        <screen>
$ qpid-config add queue hello-world
$ ./spout hello-world
$ ./drain hello-world

Message(properties={spout-id:c877e622-d57b-4df2-bf3e-6014c68da0ea:0}, content='')
        </screen>

        <para>The queue stored the message sent by <command>spout</command> and delivered
        it to <command>drain</command> when requested.</para>

	<para>Once the message has been delivered and and acknowledged
	by <command>drain</command>, it is no longer available on the queue. If we run
	<command>drain</command> one more time, no messages will be retrieved.</para>

        <screen>
$ ./drain hello-world
$
	</screen>

      </example>

      <example>
	<title>Topics</title>

	<para>This example is similar to the previous example, but it
	uses a topic instead of a queue.</para>

	<para>First, use <command>qpid-config</command> to remove the queue
	and create an exchange with the same name:</para>

        <screen>
$ qpid-config del queue hello-world
$ qpid-config add exchange topic hello-world
        </screen>

	<para>Now run <command>drain</command> and <command>spout</command> the same way we did in the previous example:</para>

	<screen>
$ ./spout hello-world
$ ./drain hello-world
$
        </screen>

        <para>Topics deliver messages immediately to any interested
        receiver, and do not store messages. Because there were no
        receivers at the time <command>spout</command> sent the
        message, it was simply discarded. When we ran
        <command>drain</command>, there were no messages to
        receive.</para>

	<para>Now let's run <command>drain</command> first, using the
	<literal>-t</literal> option to specify a timeout in seconds.
	While <command>drain</command> is waiting for messages,
	run <command>spout</command> in another window.</para>

        <para><emphasis>First Window:</emphasis></para>

        <screen>
$ ./drain -t 30 hello-word
        </screen>
        

        <para><emphasis>Second Window:</emphasis></para>

        <screen>
$ ./spout hello-word
        </screen>

        <para>Once <command>spout</command> has sent a message, return
          to the first window to see the output from
          <command>drain</command>:</para>

        <screen>
Message(properties={spout-id:7da2d27d-93e6-4803-8a61-536d87b8d93f:0}, content='')
        </screen>

        <para>You can run <command>drain</command> in several separate
          windows; each creates a subscription for the exchange, and
          each receives all messages sent to the exchange.</para>

      </example>

      <section>
	<title>Address Strings</title>

	<para>So far, our examples have used address strings that
	contain only the name of a node. An <firstterm>address
	string</firstterm> can also contain a
	<firstterm>subject</firstterm> and
	<firstterm>options</firstterm>.</para>
      
	<para>The syntax for an address string is:</para>
      
	<programlisting><![CDATA[
address_string ::=  <address> [ / <subject> ] [ ; <options> ]
options ::=  { <key> : <value>, ... }
]]></programlisting>
      
	<para>Addresses, subjects, and keys are strings.  Values can
	be numbers, strings (with optional single or double quotes),
	maps, or lists. A complete BNF for address strings appears in
	<xref linkend="section-address-string-bnf"/>.</para>


	<para>So far, the address strings in this tutorial have used
	only addresses. The following sections show how to use
	subjects and options.</para>

      </section>

      <section>
	<title>Subjects</title>


	<para>Every message has a property called
	<firstterm>subject</firstterm>, which is analogous to the
	subject on an email message. If no subject is specified, the
	message's subject is null. For convenience, address strings
	also allow a subject. If a sender's address contains a
	subject, it is used as the default subject for the messages
	it sends. 

	If a receiver's address contains a subject, it is used to
	select only messages that match the subject&mdash;the matching
	algorithm depends on the message source.
      </para>

      <para>
	In AMQP 0-10, each exchange type has its own matching
	algorithm, and queues do not provide filtering. This is
	discussed in <xref linkend="section-amqp0-10-mapping"/>.
      </para>

      <note>
	<para>
	  Currently, a receiver bound to a queue ignores subjects,
	  receiving messages from the queue without filtering.

	  In the future, if a receiver is bound to a queue, and its
	  address contains a subject, the subject will be used as a
	  selector to filter messages.
	</para>
      </note>


      <example>
        <title>Using subjects</title>

        <para>In this example we show how subjects affect message
        flow.</para>

        <para>First, let's use <command>qpid-config</command> to create a topic exchange.</para>

        <screen>
$ qpid-config add exchange topic news-service
        </screen>

        <para>Now we use drain to receive messages from <literal>news-service</literal> that match the subject <literal>sports</literal>.</para>
        <para><emphasis>First Window:</emphasis></para>
        <screen>
$ ./drain -t 30 news-service/sports
        </screen>

        <para>In a second window, let's send messages to <literal>news-service</literal> using two different subjects:</para>

        <para><emphasis>Second Window:</emphasis></para>
        <screen>
$ ./spout news-service/sports
$ ./spout news-service/news
        </screen>

        <para>Now look at the first window, the message with the
        subject <literal>sports</literal> has been received, but not
        the message with the subject <literal>news</literal>:</para>

        <screen>
Message(properties={qpid.subject:sports, spout-id:9441674e-a157-4780-a78e-f7ccea998291:0}, content='')
        </screen>

        <para>If you run <command>drain</command> in multiple
          windows using the same subject, all instances of
          <command>drain</command> receive the messages for that
          subject.</para>
      </example>
        

        <para>The AMQP exchange type we are using here,
        <literal>amq.topic</literal>, can also do more sophisticated
        matching.

	A sender's subject can contain multiple words separated by a
	<quote>.</quote> delimiter. For instance, in a news
	application, the sender might use subjects like
	<literal>usa.news</literal>, <literal>usa.weather</literal>,
	<literal>europe.news</literal>, or
	<literal>europe.weather</literal>. 

	The receiver's subject can include wildcard characters&mdash;
	<quote>#</quote> matches one or more words in the message's
	subject, <quote>*</quote> matches a single word. 

	For instance, if the subject in the source address is
	<literal>*.news</literal>, it matches messages with the
	subject <literal>europe.news</literal> or
	<literal>usa.news</literal>; if it is
	<literal>europe.#</literal>, it matches messages with subjects
	like <literal>europe.news</literal> or
	<literal>europe.pseudo.news</literal>.</para>

	  <example>
	    <title>Subjects with multi-word keys</title>

	    <para>This example uses drain and spout to demonstrate the
	    use of subjects with two-word keys.</para>

	    <para>Let's use <command>drain</command> with the subject
	    <literal>*.news</literal> to listen for messages in which
	    the second word of the key is
	    <literal>news</literal>.</para>

	    <para><emphasis>First Window:</emphasis></para>
	
	    <screen>
$ ./drain -t 30 news-service/*.news
	    </screen>

	    <para>Now let's send messages using several different
	    two-word keys:</para>

	    <para><emphasis>Second Window:</emphasis></para>

	    <screen>
$ ./spout news-service/usa.news
$ ./spout news-service/usa.sports
$ ./spout news-service/europe.sports
$ ./spout news-service/europe.news
	    </screen>

	    <para>In the first window, the messages with
	    <literal>news</literal> in the second word of the key have
	    been received:</para>

	    <screen>
Message(properties={qpid.subject:usa.news, spout-id:73fc8058-5af6-407c-9166-b49a9076097a:0}, content='')
Message(properties={qpid.subject:europe.news, spout-id:f72815aa-7be4-4944-99fd-c64c9747a876:0}, content='')
	    </screen>


	    <para>Next, let's use <command>drain</command> with the
	    subject <literal>#.news</literal> to match any sequence of
	    words that ends with <literal>news</literal>.</para>

	    <para><emphasis>First Window:</emphasis></para>

	    <screen>
$ ./drain -t 30 news-service/#.news
	    </screen>

	    <para>In the second window, let's send messages using a
	    variety of different multi-word keys:</para>

	    <para><emphasis>Second Window:</emphasis></para>

	    <screen>
$ ./spout news-service/news
$ ./spout news-service/sports
$ ./spout news-service/usa.news
$ ./spout news-service/usa.sports
$ ./spout news-service/usa.faux.news
$ ./spout news-service/usa.faux.sports
	    </screen>

        <para>In the first window, messages with
        <literal>news</literal> in the last word of the key have been
        received:</para>

        <screen>
Message(properties={qpid.subject:news, spout-id:cbd42b0f-c87b-4088-8206-26d7627c9640:0}, content='')
Message(properties={qpid.subject:usa.news, spout-id:234a78d7-daeb-4826-90e1-1c6540781eac:0}, content='')
Message(properties={qpid.subject:usa.faux.news, spout-id:6029430a-cfcb-4700-8e9b-cbe4a81fca5f:0}, content='')
        </screen>
      </example>

    </section>

    <section>
      <title>Address String Options</title>

      <para>
        The options in an address string contain additional
        information for the senders or receivers created for it,
        including:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Policies for assertions about the node to which an address
            refers.
	  </para>
	  <para>
	    For instance, in the address string <literal>my-queue;
	    {assert: always, node:{ type: queue }}</literal>, the node
	    named <literal>my-queue</literal> must be a queue; if not,
	    the address does not resolve to a node, and an exception
	    is raised.
          </para>
        </listitem>
        <listitem>
          <para>
            Policies for automatically creating or deleting the node to which an address refers.
	  </para>
	  <para>
	    For instance, in the address string <literal>xoxox ; {create: always}</literal>, 
	    the queue <literal>xoxox</literal> is created, if it does
	    not exist, before the address is resolved.
          </para>
        </listitem>
        <listitem>
          <para>
            Extension points that can be used for sender/receiver configuration.
	  </para>
	  <para>
	    For instance, if the address for a receiver is
	    <literal>my-queue; {mode: browse}</literal>, the receiver
	    works in <literal>browse</literal> mode, leaving messages
	    on the queue so other receivers can receive them.
          </para>
        </listitem>
        <listitem>
          <para>
            Extension points that rely on the functionality of specific node types.
	  </para>
	  <para>
	    For instance, the Qpid XML exchange can use XQuery to do
	    content-based routing for XML messages, or to query
	    message data using XQuery. Queries can be specified using
	    options.
          </para>
        </listitem>
      </itemizedlist>


      <para>
        Let's use some examples to show how these different kinds of
        address string options affect the behavior of senders and
        receives.
      </para>
      
      <section>
	<title>assert</title>
      <para>
	In this section, we use the <literal>assert</literal> option
	to ensure that the address resolves to a node of the required
	type.
      </para>


      <example>
	<title>Assertions on Nodes</title>

	<para>Let's use <command>qpid-config</command> to create a
        queue and a topic.</para>

	<screen>
$ qpid-config add queue my-queue
$ qpid-config add exchange topic my-topic
	</screen>
      
	<para>
        We can now use the address specified to drain to assert that it is
        of a particular type:
	</para>

	<screen>
$ ./drain 'my-queue; {assert: always, node:{ type: queue }}'
$ ./drain 'my-queue; {assert: always, node:{ type: topic }}'
2010-04-20 17:30:46 warning Exception received from broker: not-found: not-found: Exchange not found: my-queue (../../src/qpid/broker/ExchangeRegistry.cpp:92) [caused by 2 \x07:\x01]
Exchange my-queue does not exist
	</screen>

	<para>
        The first attempt passed without error as my-queue is indeed a
        queue. The second attempt however failed; my-queue is not a
        topic.
	</para>
      
	<para>
        We can do the same thing for my-topic:
	</para>

	<screen>
$ ./drain 'my-topic; {assert: always, node:{ type: topic }}'
$ ./drain 'my-topic; {assert: always, node:{ type: queue }}'
2010-04-20 17:31:01 warning Exception received from broker: not-found: not-found: Queue not found: my-topic (../../src/qpid/broker/SessionAdapter.cpp:754) [caused by 1 \x08:\x01]
Queue my-topic does not exist
	</screen>
      </example>

      <para>Now let's use the <literal>create</literal> option to
      create the queue <literal>xoxox</literal> if it does not already
      exist:</para>

      </section>

      <section>
	<title>create</title>

	<para>In previous examples, we created the queue before
	listening for messages on it. Using <literal>create:
	always</literal>, the queue is automatically created if it
	does not exist.</para>

	<example>
	  <title>Creating a Queue Automatically</title>

	<para><emphasis>First Window:</emphasis></para>
	<screen>$ ./drain -t 30 "xoxox ; {create: always}"</screen>


	<para>Now we can send messages to this queue:</para>

	<para><emphasis>Second Window:</emphasis></para>
	<screen>$ ./spout "xoxox ; {create: always}"</screen>
	
	<para>Returning to the first window, we see that <command>drain</command> has received this message:</para>

	<screen>Message(properties={spout-id:1a1a3842-1a8b-4f88-8940-b4096e615a7d:0}, content='')</screen>
      </example>

      </section>

      <section>
	<title>browse</title>
	<para>Some options specify message transfer semantics; for
	instance, they may state whether messages should be consumed or
	read in browsing mode, or specify reliability
	characteristics. The following example uses the
	<literal>browse</literal> option to receive messages without
	removing them from a queue.</para>

      <example>
        <title>Browsing a Queue</title>
        <para>
          Let's use the browse mode to receive messages without
          removing them from the queue. First we send three messages to the
          queue:
        </para>
        <screen>
$ ./spout my-queue --content one
$ ./spout my-queue --content two
$ ./spout my-queue --content three
        </screen>
        
        <para>Now we use drain to get those messages, using the browse option:</para>
        <screen>
$ ./drain 'my-queue; {mode: browse}'
Message(properties={spout-id:fbb93f30-0e82-4b6d-8c1d-be60eb132530:0}, content='one')
Message(properties={spout-id:ab9e7c31-19b0-4455-8976-34abe83edc5f:0}, content='two')
Message(properties={spout-id:ea75d64d-ea37-47f9-96a9-d38e01c97925:0}, content='three')
        </screen>
        
        <para>We can confirm the messages are still on the queue by repeating the drain:</para>
        <screen>
$ ./drain 'my-queue; {mode: browse}'
Message(properties={spout-id:fbb93f30-0e82-4b6d-8c1d-be60eb132530:0}, content='one')
Message(properties={spout-id:ab9e7c31-19b0-4455-8976-34abe83edc5f:0}, content='two')
Message(properties={spout-id:ea75d64d-ea37-47f9-96a9-d38e01c97925:0}, content='three')
        </screen>
      </example>
      </section>

      <section>
	<title>x-bindings</title>

	<para><literal>x-bindings</literal> allows an address string
	to specify properties AMQP 0-10 bindings. For instance, the
	XML Exchange is an AMQP 0-10 custom exchange provided by the
	Apache Qpid C++ broker. It allows messages to be filtered
	using XQuery; queries can address either message properties or
	XML content in the body of the message. These queries can be
	specified in addresses using x-bindings</para>


	<para>An instance of the XML Exchange must be added before it
	can be used:</para>

	<programlisting>
$ qpid-config add exchange xml xml
	</programlisting>

	<para>When using the XML Exchange, a receiver provides an
	XQuery as an x-binding argument. If the query contains a
	context item (a path starting with <quote>.</quote>), then it
	is applied to the content of the message, which must be
	well-formed XML. For instance, <literal>./weather</literal> is
	a valid XQuery, which matches any message in which the root
	element is named <literal>weather</literal>. Here is an
	address string that contains this query:</para>

      <programlisting><![CDATA[
xml; {
 link: { 
  x-bindings: [{exchange:xml, key:weather, arguments:{xquery:"./weather"} }] 
 } 
}
  ]]></programlisting>

	<para>When using longer queries with <command>drain</command>,
	it is often useful to place the query in a file, and use
	<command>cat</command> in the command line. We do this in the
	following example.</para>

      <example>
	<title>Using the XML Exchange</title>

	<para>This example uses an x-binding that contains queries, which filter based on the content of XML messages. Here is an XQuery that we will use in this example:</para>

	<programlisting>
	  <![CDATA[
let $w := ./weather 
return $w/station = 'Raleigh-Durham International Airport (KRDU)' 
   and $w/temperature_f > 50
   and $w/temperature_f - $w/dewpoint > 5
   and $w/wind_speed_mph > 7
   and $w/wind_speed_mph < 20 ]]>
	</programlisting>

	<para>We can specify this query in an x-binding to listen to messages that meet the criteria specified by the query:</para>

	<para><emphasis>First Window:</emphasis></para>
      
	<screen>
$ ./drain -f "xml; {link:{x-bindings:[{key:'weather', 
arguments:{xquery:\"$(cat rdu.xquery )\"}}]}}"
	</screen>

	<para>In another window, let's create an XML message that meets the criteria in the query, and place it in the file <filename>rdu.xml</filename>:</para>

	<programlisting>
<![CDATA[
<weather>
  <station>Raleigh-Durham International Airport (KRDU)</station>
  <wind_speed_mph>16</wind_speed_mph>
  <temperature_f>70</temperature_f>
  <dewpoint>35</dewpoint>
</weather>
	]]></programlisting>

        <para>Now let's use <command>spout</command> to send this message to the XML exchange:</para>

	<para><emphasis>Second Window:</emphasis></para>
	<screen>
spout --content "$(cat rdu.xml)" xml/weather
	</screen>

	<para>Returning to the first window, we see that the message has been received:</para>
	
	<screen><![CDATA[$ ./drain -f "xml; {link:{x-bindings:[{exchange:'xml', key:'weather', arguments:{xquery:\"$(cat rdu.xquery )\"}}]}}"
Message(properties={qpid.subject:weather, spout-id:31c431de-593f-4bec-a3dd-29717bd945d3:0}, 
content='<weather>
  <station>Raleigh-Durham International Airport (KRDU)</station>
  <wind_speed_mph>16</wind_speed_mph>
  <temperature_f>40</temperature_f>
  <dewpoint>35</dewpoint>
</weather>') ]]>
	</screen>
      </example>
      </section>

<!--
	<para>When sending data using <command>cat</command> to provide arguments to <command>spout</command>, you can use <command>sed</command> to change the values that are sent:</para>

	<screen>
spout - -content "$(cat rdu.xml | sed -e 's/70/45/')" xml/weather
	</screen>
-->

      <!--
         TODO: Add some reliability option examples
        -->

      <section>
	<title>Address String Options - Reference</title>

      <table pgwide="1">
        <title>Address String Options</title>
        <tgroup cols="3">
          <thead>
	    <colspec colnum="1" colwidth="1*"/>
	    <colspec colnum="2" colwidth="3*"/>
	    <colspec colnum="3" colwidth="3*"/>
	    <row>
	      <entry>option</entry>
	      <entry>value</entry>
	      <entry>semantics</entry>
	    </row>
          </thead>
          <tbody>
	    <row>
	      <entry>
	        assert
	      </entry>
	      <entry>
	        one of: always, never, sender or receiver
	      </entry>
	      <entry>
	        Asserts that the properties specified in the node option
	        match whatever the address resolves to. If they do not,
	        resolution fails and an exception is raised. <!-- ###
	                                                          Which exception -->
	      </entry>
	    </row>

	    <row>
	      <entry>
	        create
	      </entry>
	      <entry>
                one of: always, never, sender or receiver
	      </entry>
	      <entry>
	        Creates the node to which an address refers if it does
	        not exist. No error is raised if the node does
	        exist. The details of the node may be specified in the
	        node option.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        delete
	      </entry>
	      <entry>
                one of: always, never, sender or receiver
	      </entry>
	      <entry>
	        Delete the node when the sender or receiver is closed.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        node
	      </entry>
	      <entry>
	        A nested map containing the entries shown in <xref linkend="table-node-properties"/>.
	      </entry>
	      <entry>
                Specifies properties of the node to which the address
                refers. These are used in conjunction with the assert or
                create options.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        link
	      </entry>
	      <entry>
	        A nested map containing the entries shown in <xref linkend="table-link-properties"/>.
	      </entry>
	      <entry>
                Used to control the establishment of a conceptual link
                from the client application to or from the target/source
                address.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        mode
	      </entry>
	      <entry>
	        one of: browse, consume
	      </entry>
	      <entry>
                This option is only of relevance for source addresses
                that resolve to a queue. If browse is specified the
                messages delivered to the receiver are left on the queue
                rather than being removed. If consume is specified the
                normal behaviour applies; messages are removed from teh
                queue once the client acknoweldges their receipt.
	      </entry>
	    </row>
          </tbody>
        </tgroup>
      </table>


      <table id="table-node-properties" pgwide="1">
        <title>Node Properties</title>
        <tgroup cols="3">
          <thead>
	    <colspec colnum="1" colwidth="1*"/>
	    <colspec colnum="2" colwidth="3*"/>
	    <colspec colnum="3" colwidth="3*"/>
	    <row>
	      <entry>property</entry>
	      <entry>value</entry>
	      <entry>semantics</entry>
	    </row>
          </thead>
          <tbody>
	    <row>
	      <entry>
	        type
	      </entry>
	      <entry>
	        topic, queue
	      </entry>
	      <entry>
		Indicates the type of the node.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        durable
	      </entry>	       
	      <entry>
	        True, False
	      </entry>
	      <entry>
                Indicates whether the node survives a loss of
                volatile storage e.g. if the broker is restarted.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        x-declare
	      </entry>
	      <entry>
	        A nested map whose values correspond to the valid fields
	        on an AMQP 0-10 queue-declare or exchange-declare
	        command.
	      </entry>
	      <entry>
                These values are used to fine tune the creation or
                assertion process. Note however that they are protocol
                specific.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        x-bindings
	      </entry>
	      <entry>
	        A nested list in which each binding is represented by
	        a map. The entries of the map for a binding contain
	        the fields that describe an AMQP 0-10 binding. Here is
	        the format for x-bindings:

<programlisting><![CDATA[
[
 {
  exchange: <exchange>,
  queue: <queue>,
  key: <key>,
  arguments: { 
    <key_1>: <value_1>, 
    ..., 
    <key_n>: <value_n> }
 },
 ...
]
]]></programlisting>
	      </entry>
	      <entry>
                In conjunction with the create option, each of these
                bindings is established as the address is resolved. In
                conjunction with the assert option, the existence of
                each of these bindings is verified during
                resolution. Again, these are protocol specific.
	      </entry>
	    </row>
          </tbody>
        </tgroup>
      </table>

      <table id="table-link-properties" pgwide="1">
        <title>Link Properties</title>
        <tgroup cols="3">
          <thead>
	    <colspec colnum="1" colwidth="1*"/>
	    <colspec colnum="2" colwidth="3*"/>
	    <colspec colnum="3" colwidth="3*"/>
	    <row>
	      <entry>option</entry>
	      <entry>value</entry>
	      <entry>semantics</entry>
	    </row>
          </thead>
          <tbody>
	    <row>
	      <entry>
	        reliability
	      </entry>
	      <entry>
	        one of: unreliable, at-least-once, at-most-once, exactly-once
	      </entry>
	      <entry><!-- from https://issues.apache.org/jira/browse/QPID-2380 -->
		Reliability indicates the level of reliability that
		the sender or receiver.  <literal>unreliable</literal>
		and <literal>at-most-once</literal> are currently
		treated as synonyms, and allow messages to be lost if
		a broker crashes or the connection to a broker is
		lost. <literal>at-least-once</literal> guarantees that
		a message is not lost, but duplicates may be
		received. <literal>exactly-once</literal> guarantees
		that a message is not lost, and is delivered precisely
		once.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        durable
	      </entry>	       
	      <entry>
	        True, False
	      </entry>
	      <entry>
                Indicates whether the link survives a loss of
                volatile storage e.g. if the broker is restarted.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        x-declare
	      </entry>
	      <entry>
	        A nested map whose values correspond to the valid fields
	        of an AMQP 0-10 queue-declare command.
	      </entry>
	      <entry>
                These values can be used to customise the subscription
	        queue in the case of receiving from an exchange. Note
	        however that they are protocol specific.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        x-subscribe
	      </entry>
	      <entry>
	        A nested map whose values correspond to the valid fields
	        of an AMQP 0-10 message-subscribe command.
	      </entry>
	      <entry>
                These values can be used to customise the subscription.
	      </entry>
	    </row>
	    <row>
	      <entry>
	        x-bindings
	      </entry>
	      <entry>
	        A nested list each of whose entries is a map that may
	        contain fields (queue, exchange, key and arguments)
	        describing an AMQP 0-10 binding.
	      </entry>
	      <entry>
                These bindings are established during resolution
                independent of the create option. They are considered
                logically part of the linking process rather than of
                node creation.
	      </entry>
	    </row>
          </tbody>
        </tgroup>
      </table>

    </section>
  </section>

  <section id="section-address-string-bnf">
    <title>Address String Grammar</title>

    <para>This section provides a formal grammar for address strings.</para>

    <formalpara>
      <title>Tokens</title>
      <para>The following regular expressions define the tokens used
      to parse address strings:</para></formalpara>
<programlisting><![CDATA[
LBRACE: \\{
RBRACE: \\}
LBRACK: \\[
RBRACK: \\]
COLON:  :
SEMI:   ;
SLASH:  /
COMMA:  ,
NUMBER: [+-]?[0-9]*\\.?[0-9]+
ID:     [a-zA-Z_](?:[a-zA-Z0-9_-]*[a-zA-Z0-9_])?
STRING: "(?:[^\\\\"]|\\\\.)*"|\'(?:[^\\\\\']|\\\\.)*\'
ESC:    \\\\[^ux]|\\\\x[0-9a-fA-F][0-9a-fA-F]|\\\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]
SYM:    [.#*%@$^!+-]
WSPACE: [ \\n\\r\\t]+
]]></programlisting>

    <formalpara>
      <title>Grammar</title>
      <para>The formal grammar for addresses is given below:</para>
    </formalpara>

    <programlisting><![CDATA[
address := name [ "/" subject ] [ ";" options ]
   name := ( part | quoted )+
subject := ( part | quoted | "/" )*
 quoted := STRING / ESC
   part := LBRACE / RBRACE / COLON / COMMA / NUMBER / ID / SYM
options := map
    map := "{" ( keyval ( "," keyval )* )? "}"
 keyval "= ID ":" value
  value := NUMBER / STRING / ID / map / list
   list := "[" ( value ( "," value )* )? "]"
   ]]></programlisting>


    <formalpara>
      <title>Address String Options</title>
      <para>The address string options map supports the following parameters:</para>
    </formalpara>

    <programlisting><![CDATA[
<name> [ / <subject> ] ; {
  create: always | sender | receiver | never,
  delete: always | sender | receiver | never,
  assert: always | sender | receiver | never,
  mode: browse | consume,
  node: {
    type: queue | topic,
    durable: True | False,
    x-declare: { ... <declare-overrides> ... },
    x-bindings: [<binding_1>, ... <binding_n>]
  },
  link: {
    name: <link-name>,
    durable: True | False,
    reliability: unreliable | at-most-once | at-least-once | exactly-once,
    x-declare: { ... <declare-overrides> ... },
    x-bindings: [<binding_1>, ... <binding_n>],
    x-subscribe: { ... <subscribe-overrides> ... }
  }
}
]]></programlisting>


    <itemizedlist>
      <title>Create, Delete, and Assert Policies</title>
      <para>The create, delete, and assert policies specify who should
      perfom the associated action:</para>
      <listitem><para><emphasis>always</emphasis>: the action is performed by any messaging client</para></listitem>
      <listitem><para><emphasis>sender</emphasis>: the action is only performed by a sender</para></listitem>
      <listitem><para><emphasis>receiver</emphasis>: the action is only performed by a receiver</para></listitem>
      <listitem><para><emphasis>never</emphasis>: the action is never performed (this is the default)</para></listitem>
    </itemizedlist>

    <itemizedlist>
      <title>Node-Type</title>
      <para>The node-type is one of:</para>
       <listitem><para><emphasis>topic</emphasis>: in the AMQP 0-10
       mapping, a topic node defaults to the topic exchange, x-declare
       may be used to specify other exchange types</para></listitem>
       <listitem><para><emphasis>queue</emphasis>: this is the default node-type</para></listitem>
    </itemizedlist>
  </section>


</section>

<section>
      <title>Logging</title>

      <para>To simplify debugging, Qpid provides a logging facility
      that prints out messaging events.</para>

      <section>
	<title>Logging in C++</title>
	<para>The Qpidd broker and C++ clients can both use environment
	variables to enable logging. Use QPID_LOG_ENABLE to set the
	level of logging you are interested in (trace, debug, info,
	notice, warning, error, or critical):</para>

<screen>
$ export QPID_LOG_ENABLE="warning+"
</screen>

      <para>The Qpidd broker and C++ clients use QPID_LOG_OUTPUT to
      determine where logging output should be sent. This is either a
      file name or the special values stderr, stdout, or syslog:</para>

<screen>
export QPID_LOG_TO_FILE="/tmp/myclient.out"
</screen>

      </section>
	
	<section>
		<title>Logging in Python</title>
		<para>
			The Python client library supports logging using the standard Python logging module. The easiest way to do logging is to use the <command>basicConfig()</command>, which reports all warnings and errors:
		</para>
		
<programlisting>from logging import basicConfig
basicConfig()
</programlisting>
		<para>
			Qpidd also provides a convenience method that makes it easy to specify the level of logging desired. For instance, the following code enables logging at the <command>DEBUG</command> level:
		</para>
		
<programlisting>from qpid.log import enable, DEBUG
enable("qpid.messaging.io", DEBUG)
</programlisting>
		<para>
			For more information on Python logging, see <ulink url="http://docs.python.org/lib/node425.html">http://docs.python.org/lib/node425.html</ulink>. For more information on Qpid logging, use <command>$ pydoc qpid.log</command>.
		</para>
	</section>
</section>

    
    <section>
      <title>Receiving Messages from Multiple Sources</title>

      <para>A receiver can only read from one source, but many
      programs need to be able to read messages from many sources,
      preserving the original sequence of the messages. In the Qpid
      Messaging API, a program can ask a session for the <quote>next
      receiver</quote>; that is, the receiver that is responsible for
      the next available message. The following example shows how this
      is done in C++ and Python.</para>

      <example>
	<title>Receiving Messages from Multiple Sources</title>

	<para>C++:</para>

	<programlisting><![CDATA[
Receiver receiver1 = session.createReceiver(address1);
Receiver receiver2 = session.createReceiver(address2);

Message message =  session.nextReceiver().fetch();
session.acknowledge(); // acknowledge message receipt
std::cout << message.getContent() << std::endl;
]]>	  </programlisting>

	<para>Python:</para>
	<programlisting><![CDATA[
receiver1 = session.receiver(address1)
receiver2 = session.receiver(address)
message = session.next_receiver().fetch()
print message.content
]]>	  </programlisting>
      </example>
    </section>

    <section>
      <title>Request / Response</title>
      <para>Request / Response applications use the reply-to property,
      described in <xref
      linkend="table-amqp0-10-message-properties"/>, to allow a server
      to respond to the client that sent a message. A server sets up a
      service queue, with a name known to clients. A client creates a
      private queue for the server's response, creates a message for a
      request, sets the request's reply-to property to the address of
      the client's response queue, and sends the request to the
      service queue. The server sends the response to the address
      specified in the request's reply-to property.
      </para>
      <example>
	<title>Request / Response Applications in C++</title>

	<para>This example shows the C++ code for a client and server
	that use the request / response pattern.</para>

	<para>The server creates a service queue and waits for a
	message to arrive. If it receives a message, it sends a
	message back to the sender.</para>

	<programlisting><![CDATA[Receiver receiver = session.createReceiver("service_queue; {create: always}");

Message request = receiver.fetch();
const Address&amp; address = request.getReplyTo(); // Get "reply-to" from request ...
if (address) {
  Sender sender = session.createSender(address); // ... send response to "reply-to"
  Message response("pong!");
  sender.send(response);
  session.acknowledge();
}
     ]]></programlisting>

	<para>The client creates a sender for the service queue, and
	also creates a response queue that is deleted when the
	client closes the receiver for the response queue. In the C++
	client, if the address starts with the character
	<literal>#</literal>, it is given a unique name.</para>

	<programlisting><![CDATA[
Sender sender = session.createSender("service_queue");

Address responseQueue("#response-queue; {create:always, delete:always}");
Receiver receiver = session.createReceiver(responseQueue);

Message request;
request.setReplyTo(responseQueue);
request.setContent("ping");
sender.send(request);
Message response = receiver.fetch();
std::cout << request.getContent() << " -> " << response.getContent() << std::endl;
]]>	  </programlisting>

	<para>The client sends the string <literal>ping</literal> to
	the server. The server sends the response
	<literal>pong</literal> back to the same client, using the
	<varname>replyTo</varname> property.</para>

      </example>
<!--
      <example>
	<title>Request / Response Applications in Python</title>
	<programlisting>### TODO</programlisting>
      </example>
-->
    </section>
    <section id="section-Maps">
      <title>Maps in Message Content</title>
      
      <para>Many messaging applications need to exchange data across
      languages and platforms, using the native datatypes of each
      programming language. AMQP provides a set of portable datatypes,
      but does not directly support a set of named type/value
      pairs. Java JMS provides the <classname>MapMessage</classname>
      interface, which allows sets of named type/value pairs, but does
      not provide a set of portable datatypes.</para> 

      <para>The Qpid Messaging API supports maps in message
      content. Unlike JMS, any message can contain maps. These maps
      are supported in each language using the conventions of the
      language. In Java, we implement the
      <classname>MapMessage</classname> interface; in Python, we
      support <classname>dict</classname> and
      <classname>list</classname> in message content; in C++, we
      provide the <classname>Variant::Map</classname> and
      <classname>Variant::List</classname> classes to represent maps
      and lists. In all languages, messages are encoded using AMQP's
      portable datatypes.
      </para>

      <tip>
      <para>Because of the differences in type systems among
      languages, the simplest way to provide portable messages is to
      rely on maps, lists, strings, 64 bit signed integers, and
      doubles for messages that need to be exchanged across languages
      and platforms.</para>
      </tip>

      <section id="section-Python-Maps">
	<title>Qpid Maps in Python</title>

	<para>In Python, Qpid supports the <classname>dict</classname> and <classname>list</classname> types directly in message content. The following code shows how to send these structures in a message:</para>

	<example>
	  <title>Sending Qpid Maps in Python</title>
	  <programlisting><![CDATA[
from qpid.messaging import *
# !!! SNIP !!!

content = {'Id' : 987654321, 'name' : 'Widget', 'percent' : 0.99}
content['colours'] = ['red', 'green', 'white']
content['dimensions'] = {'length' : 10.2, 'width' : 5.1,'depth' : 2.0};
content['parts'] = [ [1,2,5], [8,2,5] ]
content['specs'] = {'colors' : content['colours'], 
                    'dimensions' : content['dimensions'], 
                    'parts' : content['parts'] }
message = Message(content=content)
sender.send(message)
    ]]>   </programlisting>
	</example>


      <para>The following table shows the datatypes that can be sent in a Python map message,
 and the corresponding datatypes that will be received by clients in Java or C++.</para>
      

	<table id="table-Python-Maps" >
	<title>Python Datatypes in Maps</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Python Datatype</entry>
	      <entry>&rarr; C++</entry>
	      <entry>&rarr; Java</entry>
	    </row>
	  </thead>
	  <tbody>
   	    <row><entry>bool</entry><entry>bool</entry><entry>boolean</entry></row>
	    <row><entry>int</entry><entry>int64</entry><entry>long</entry></row>
	    <row><entry>long</entry><entry>int64</entry><entry>long</entry></row>
	    <row><entry>float</entry><entry>double</entry><entry>double</entry></row>
	    <row><entry>unicode</entry><entry>string</entry><entry>java.lang.String</entry></row>
	    <row><entry>uuid</entry><entry>qpid::types::Uuid</entry><entry>java.util.UUID</entry></row>
	    <row><entry>dict</entry><entry>Variant::Map</entry><entry>java.util.Map</entry></row>
	    <row><entry>list</entry><entry>Variant::List</entry><entry>java.util.List</entry></row>
	  </tbody>
	</tgroup>
      </table>

      </section>




      <section id="section-cpp-Maps">
	<title>Qpid Maps in C++</title>


	<para>In C++, Qpid defines the the
	<classname>Variant::Map</classname> and
	<classname>Variant::List</classname> types, which can be
	encoded into message content. The following code shows how to
	send these structures in a message:</para>

	<example>
	  <title>Sending Qpid Maps in C++</title>
	<programlisting><![CDATA[
using namespace qpid::types;

// !!! SNIP !!!

Message message;
Variant::Map content;
content["id"] = 987654321;
content["name"] = "Widget";
content["percent"] = 0.99;
Variant::List colours;
colours.push_back(Variant("red"));
colours.push_back(Variant("green"));
colours.push_back(Variant("white"));
content["colours"] = colours;

Variant::Map dimensions;
dimensions["length"] = 10.2;
dimensions["width"] = 5.1;
dimensions["depth"] = 2.0;
content["dimensions"]= dimensions; 

Variant::List part1;
part1.push_back(Variant(1));
part1.push_back(Variant(2));
part1.push_back(Variant(5));
 
Variant::List part2;
part2.push_back(Variant(8));
part2.push_back(Variant(2));
part2.push_back(Variant(5));
 
Variant::List parts;
parts.push_back(part1);
parts.push_back(part2);
content["parts"]= parts; 

Variant::Map specs;
specs["colours"] = colours; 
specs["dimensions"] = dimensions; 
specs["parts"] = parts; 
content["specs"] = specs;

encode(content, message);
sender.send(message, true);
]]>     </programlisting>
	</example>

	<para>The following table shows the datatypes that can be sent
	in a C++ map message, and the corresponding datatypes that
	will be received by clients in Java and Python.</para>
      
	<table  id="table-cpp-Maps">
	<title>C++ Datatypes in Maps</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>C++ Datatype</entry>
	      <entry>&rarr; Python</entry>
	      <entry>&rarr; Java</entry>
	    </row>
	  </thead>
	  <tbody>
   	    <row><entry>bool</entry><entry>bool</entry><entry>boolean</entry></row>
	    <row><entry>uint16</entry><entry>int | long</entry><entry>short</entry></row>
	    <row><entry>uint32</entry><entry>int | long</entry><entry>int</entry></row>
	    <row><entry>uint64</entry><entry>int | long</entry><entry>long</entry></row>
	    <row><entry>int16</entry><entry>int | long</entry><entry>short</entry></row>
	    <row><entry>int32</entry><entry>int | long</entry><entry>int</entry></row>
	    <row><entry>int64</entry><entry>int | long</entry><entry>long</entry></row>
	    <row><entry>float</entry><entry>float</entry><entry>float</entry></row>
	    <row><entry>double</entry><entry>float</entry><entry>double</entry></row>
	    <row><entry>string</entry><entry>unicode</entry><entry>java.lang.String</entry></row>
	    <row><entry>qpid::types::Uuid</entry><entry>uuid</entry><entry>java.util.UUID</entry></row>
	    <row><entry>Variant::Map</entry><entry>dict</entry><entry>java.util.Map</entry></row>
	    <row><entry>Variant::List</entry><entry>list</entry><entry>java.util.List</entry></row>
	  </tbody>
	</tgroup>
      </table>
      </section>

      
</section> 
        <section>
      <title>Performance</title>
      <para>
         Clients can often be made significantly faster by batching acknowledgements and setting the capacity of receivers to allow prefetch. The size of a sender's replay buffer can also affect performance.
      </para>
      <section>
	<title>Batching Acknowledgements</title>

	<para>Many of the simple examples we have shown retrieve a message and immediately acknowledge it. Because each acknowledgement results in network traffic, you can dramatically increase performance by acknowledging messages in batches. For instance, an application can read a number of related messages, then acknowledge the entire batch, or an application can acknowledge after a certain number of messages have been received or a certain time period has elapsed. Messages are not removed from the broker until they are acknowledged, so guaranteed delivery is still available when batching acknowledgements.</para>
      </section>


      <section>
	<title>Prefetch</title>   

	<para>By default, a receiver retrieves the next message from the server, one message at a time, which provides intuitive results when writing and debugging programs, but does not provide optimum performance. To create an input buffer, set the capacity of the receiver to the size of the desired input buffer; for many applications, a capacity of 100 performs well. </para>

<!--
###	sender: capacity of replay buffer (not yet acknowledged messages), these are resent with failover
-->

	<example>
	  <title>Prefetch</title>
	  
	  <para>C++</para>
	  <programlisting>
Receiver receiver = session.createReceiver(address);
receiver.setCapacity(100);
Message message = receiver.fetch();
	  </programlisting>
<!--
	  <para>Python</para>
	  <programlisting>
	  </programlisting>
-->
  
	</example>
      </section>

      <section>
	<title>Sizing the Replay Buffer</title>

	<para>In order to guarantee delivery, a sender automatically
	keeps messages in a replay buffer until the messaging broker
	acknowledges that they have been received. The replay buffer
	is held in memory, and is never paged to disk. For most
	applications, the default size of the replay buffer works
	well. A large replay buffer requires more memory, a small
	buffer can slow down the client because it can not send new
	messages if the replay buffer is full, and must wait for
	existing sends to be acknowledged.</para>

	<example>
	  <title>Sizing the Replay Buffer</title>
	  <para>C++</para>
 
	  <programlisting>
Sender sender = session.createSender(address);
sender.setCapacity(100);
	  </programlisting>
	</example>
	  
      </section>

    </section>


    <section>
      <title>Reliability</title>
      <para>The Qpid Messaging API supports automatic reconnect, guaranteed delivery via persistent messages, reliability options in senders and receivers, and cluster failover. This section shows how programs can take advantage of these features.</para>
      <section>
	<title>Reconnect</title>
	<para>Connections in the Qpid Messaging API support automatic
	reconnect if a connection is lost. This is done using connection
	options. The following example shows how to use connection options in C++ and Python.</para>

	<example>
	  <title>Specifying Connection Options in C++ and Python</title>

	  <para>In C++, these options are set using <function>Connection::setOption()</function>:</para>

	  <programlisting><![CDATA[
Connection connection(broker);
connection.setOption("reconnect", true);
try {
    connection.open();
    !!! SNIP !!!
    ]]></programlisting>

	  <para>In Python, these options are set using named arguments in
	  the <function>Connection</function> constructor:</para>

	  <programlisting><![CDATA[
connection = Connection("localhost:5672", reconnect=True)
try:
  connection.open()
  !!! SNIP !!!
  ]]></programlisting>

	  <para>See the reference documentation for details on how to set
	  these on connections for each language.</para>
	</example>

	<para>The following table lists the connection options that can
	be used.</para>

	<table pgwide="1">
	  <title>Connection Options</title>
	  <tgroup cols="3">
	    <thead>
	      <colspec colnum="1" colwidth="1*"/>
	      <colspec colnum="2" colwidth="1*"/>
	      <colspec colnum="3" colwidth="3*"/>
	      <row>
		<entry>option</entry>
		<entry>value</entry>
		<entry>semantics</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>
		  reconnect
		</entry>
		<entry>
		  True, False
		</entry>
		<entry>
		  Transparently reconnect if the connection is lost.
		</entry>
	      </row>
	      <row>
		<entry>
		  reconnect_timeout
		</entry>
		<entry>
		  N
		</entry>
		<entry>
		  Total number of seconds to continue reconnection attempts before giving up and raising an exception.
		</entry>
	      </row>
	      <row>
		<entry>
		  reconnect_limit
		</entry>
		<entry>
		  N
		</entry>
		<entry>
		  Maximum number of reconnection attempts before giving up and raising an exception.
		</entry>
	      </row>
	      <row>
		<entry>
		  reconnect_interval_min
		</entry>
		<entry>
		  N
		</entry>
		<entry>
		  Minimum number of seconds between reconnection attempts. The first reconnection attempt is made immediately; if that fails, the first reconnection delay is set to the value of <literal>reconnect_interval_min</literal>; if that attempt fails, the reconnect interval increases exponentially until a reconnection attempt succeeds or <literal>reconnect_interval_max</literal> is reached.
		</entry>
	      </row>
	      <row>
		<entry>
		  reconnect_interval_max
		</entry>
		<entry>
		  N
		</entry>
		<entry>
		  Maximum reconnect interval.
		</entry>
	      </row>
	      <row>
		<entry>
		  reconnect_interval
		</entry>
		<entry>
		  N
		</entry>
		<entry>
		  Sets both <literal>reconnection_interval_min</literal> and <literal>reconnection_interval_max</literal> to the same value.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </section>
      <section>
	<title>Guaranteed Delivery</title>

	<para>If a queue is durable, the queue survives a messaging
	broker crash, as well as any durable messages that have been
	placed on the queue. These messages will be delivered when the
	messaging broker is restarted. Delivery is guaranteed if and
	only if both the message and the queue are durable. Guaranteed
	delivery requires a persistence module, such as the one
	available from <ulink
	url="http://QpidComponents.org">QpidComponents.org</ulink>.</para>

	<example>
	  <title>Guaranteed Delivery</title>

	  <para>C++:</para>

	  <programlisting><![CDATA[
Sender sender = session.createSender("durable-queue");

Message message("Hello world!");
message.setDurable(1);

sender.send(Message("Hello world!"));
]]></programlisting>
<!--
	  <para>Python:</para>
-->
	</example>

      </section>


      <section>
	<title>Reliability Options in Senders and Receivers</title>

	<para>When creating a sender or a receiver, you can specify a reliability option in the address string. For instance, the following specifies <literal>at-least-once</literal> as the reliability mode for a sender:</para>

	<programlisting>
Sender = session.createSender("topic;{create:always,link:{reliability:at-least-once}}");
	</programlisting>

	<para>The modes <literal>unreliable</literal>, <literal>at-most-once</literal>, <literal>at-least-once</literal>, and <literal>exactly-once</literal> are supported. These modes govern the reliability of the connection between the client and the messaging broker.</para>

	<para>The modes <literal>unreliable</literal> and <literal>at-most-once</literal> are currently synonyms. In a receiver, this mode means that messages received on an auto-delete subscription queue may be lost in the event of a broker failure. In a sender, this mode means that the sender can consider a message sent as soon as it is written to the wire, and need not wait for broker acknowledgement before considering the message sent.</para>

	<para>The mode <literal>at-most-once</literal> ensures that messages are not lost, but duplicates of a message may occur. In a receiver, this mode ensures that messages are not lost in event of a broker failure. In a sender, this means that messages are kept in a replay buffer after they have been sent, and removed from this buffer only after the broker acknowledges receipt; if a broker failure occurs, messages in the replay buffer are resent upon reconnection. The mode <literal>exactly-once</literal> is similar to <literal>at-most-once</literal>, but eliminates duplicate messages.</para>

	<!-- What is the default? ### -->

      </section>

      <section>
	<title>Cluster Failover</title>

	<para>The messaging broker can be run in clustering mode, which provides high reliability at-least-once messaging. If one broker in a cluster fails, clients can choose another broker in the cluster and continue their work.</para>

	<para>In C++, the <classname>FailoverUpdates</classname> class keeps track of the brokers in a cluster, so a reconnect can select another broker in the cluster to connect to:</para>

	<example>
	  <title>Cluster Failover in C++</title>
	    <programlisting><![CDATA[
#include <qpid/messaging/FailoverUpdates.h>
...
Connection connection(broker);
connection.setOption("reconnect", true);
try {
    connection.open();
    std::auto_ptr<FailoverUpdates> updates(new FailoverUpdates(connection));]]>
	</programlisting>
	</example>
      </section>

    </section>


    <section>
      <title>Security</title>

      <para>Qpid provides authentication, rule-based authorization, encryption, and digital signing.</para>

      <para>Authentication is done using Simple Authentication and
      Security Layer (SASL) to authenticate client connections to the
      broker. SASL is a framework that supports a variety of
      authentication methods. For secure applications, we suggest
      CRAM-MD5, DIGEST-MD5, or GSSAPI (Kerberos). The ANONYMOUS method
      is not secure. The PLAIN method is secure only when used
      together with SSL.</para>

      <para>To enable Kerberos in a client, set the <varname>sals-mechanism</varname> connection option to <literal>GSSAPI</literal>:</para>


      <programlisting>
Connection connection(broker);
connection.setOption("sasl-mechanism", "GSSAPI");
try {
    connection.open();
    ...
      </programlisting>

      <para>For Kerberos authentication, if the user running the
      program is already authenticated, e.g. using
      <command>kinit</command>, there is no need to supply a user name
      or password. If you are using another form of authentication, or are not already authenticated with Kerberos, you can supply these as connection options:</para>

      <programlisting>
connection.setOption("username", "mick");
connection.setOption("password", "pa$$word");
      </programlisting>

      <para>Encryption and signing are done using SSL (they can also be done using SASL, but SSL provides stronger encryption). To enable SSL, set the <varname>protocol</varname> connection option to <literal>ssl</literal>:</para>

      <programlisting>
connection.setOption("protocol", "ssl");
      </programlisting>

      <para>Use the following environment variables to configure the SSL client:</para>

      <table>
	<title>SSL Client Environment Variables for C++ clients</title>
	<tgroup align="left" cols="2" colsep="1" rowsep="1">
	  <colspec colname="c1"></colspec>
	  <colspec colname="c2"></colspec>
	  <thead>
	    <row>
	      <entry align="center" nameend="c2" namest="c1">
		SSL Client Options for C++ clients
	      </entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>
		<command>SSL_USE_EXPORT_POLICY</command>
	      </entry>
	      <entry>
		Use NSS export policy
	      </entry>
	    </row>
	    <row>
	      <entry>
		<command>SSL_CERT_PASSWORD_FILE <replaceable>PATH</replaceable></command>
	      </entry>
	      <entry>
		File containing password to use for accessing certificate database
	      </entry>
	    </row>
	    <row>
	      <entry>
		<command>SSL_CERT_DB <replaceable>PATH</replaceable></command>
	      </entry>
	      <entry>
		Path to directory containing certificate database
	      </entry>
	    </row>
	    <row>
	      <entry>
		<command>SSL_CERT_NAME <replaceable>NAME</replaceable></command>
	      </entry>
	      <entry>
		Name of the certificate to use. When SSL client authentication is enabled, a certificate name should normally be provided.
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

    </section>

    <section>
      <title>Transactions</title>
      <para>In AMQP, transactions cover the semantics of enqueues and
      dequeues.</para>

      <para>When sending messages, a transaction tracks enqueues
      without actually delivering the messages, a commit places
      messages on their queues, and a rollback discards the
      enqueues.</para>

      <para>When receiving messages, a transaction tracks dequeues
      without actually removing acknowledged messages, a commit
      removes all acknowledged messages, and a rollback discards
      acknowledgements. A rollback does not release the message, it
      must be explicitly released to return it to the queue.</para>

      <example>
	<title>Transactions</title>
	<para>C++:</para>
	<programlisting><![CDATA[
Connection connection(broker);
Session session =  connection.createTransactionalSession();
...
if (smellsOk())
   session.commit();
else 
   session.rollback();
   ]]></programlisting>
<!--
	<para>Python</para>
	<programlisting><![CDATA[
### TODO
   ]]></programlisting>
-->
      </example>

    </section>





  <section id="section-amqp0-10-mapping">
    <title>The AMQP 0-10 mapping</title>

    <para>
      This section describes the AMQP 0-10 mapping for the Qpid
      Messaging API.
    </para>
    <para>
        The interaction with the broker triggered by creating a sender
        or receiver depends on what the specified address resolves
        to. Where the node type is not specified in the address, the
        client queries the broker to determine whether it refers to a
        queue or an exchange.
    </para>
    <para>
        When sending to a queue, the queue's name is set as the
        routing key and the message is transfered to the default (or
        nameless) exchange. When sending to an exchange, the message
        is transfered to that exchange and the routing key is set to
        the message subject if one is specified. A default subject may
        be specified in the target address. The subject may also be
        set on each message individually to override the default if
        required. In each case any specified subject is also added as
        a qpid.subject entry in the application-headers field of the
        message-properties.
      </para>
      <para>
        When receiving from a queue, any subject in the source address
        is currently ignored. The client sends a message-subscribe
        request for the queue in question. The accept-mode is
        determined by the reliability option in the link properties;
        for unreliable links the accept-mode is none, for reliable
        links it is explicit. The default for a queue is reliable. The
        acquire-mode is determined by the value of the mode option. If
        the mode is set to browse the acquire mode is not-acquired,
        otherwise it is set to pre-acquired. The exclusive and
        arguments fields in the message-subscribe command can be
        controlled using the x-subscribe map.
      </para>
      <para>
        When receiving from an exchange, the client creates a
        subscription queue and binds that to the exchange. The
        subscription queue's arguments can be specified using the
        x-declare map within the link properties. The reliability
        option determines most of the other parameters. If the
        reliability is set to unreliable then an auto-deleted,
        exclusive queue is used meaning that if the client or
        connection fails messages may be lost. For exactly-once the
        queue is not set to be auto-deleted. The durability of the
        subscription queue is determined by the durable option in the
        link properties. The binding process depends on the type of
        the exchange the source address resolves to.
      </para>

      <itemizedlist>
        <listitem>
          <para>
            For a topic exchange, if no subject is specified and no
            x-bindings are defined for the link, the subscription
            queue is bound using a wildcard matching any routing key
            (thus satisfying the expectation that any message sent to
            that address will be received from it). If a subject is
            specified in the source address however, it is used for
            the binding key (this means that the subject in the source
            address may be a binding pattern including wildcards).
          </para>
        </listitem>
        <listitem>
          <para>
            For a fanout exchange the binding key is irrelevant to
            matching. A receiver created from a source address that
            resolves to a fanout exchange receives all messages
            sent to that exchange regardless of any subject the source
            address may contain. An x-bindings element in the link
            properties should be used if there is any need to set the
            arguments to the bind.
          </para>
        </listitem>
        <listitem>
          <para>
            For a direct exchange, the subject is used as the binding
            key. If no subject is specified an empty string is used as
            the binding key.
          </para>
        </listitem>
        <listitem>
          <para>
            For a headers exchange, if no subject is specified the
            binding arguments simply contain an x-match entry and no
            other entries, causing all messages to match. If a subject
            is specified then the binding arguments contain an x-match
            entry set to all and an entry for qpid.subject whose value
            is the subject in the source address (this means the
            subject in the source address must match the message
            subject exactly). For more control the x-bindings element
            in the link properties must be used.
          </para>
        </listitem>
        <listitem>
          <para>
            For the XML exchange,<footnote><para>Note that the XML
            exchange is not a standard AMQP exchange type. It is a
            Qpid extension and is currently only supported by the C++
            broker.</para></footnote> if a subject is specified it is
            used as the binding key and an XQuery is defined that
            matches any message with that value for
            qpid.subject. Again this means that only messages whose
            subject exactly match that specified in the source address
            are received. If no subject is specified then the empty
            string is used as the binding key with an xquery that will
            match any message (this means that only messages with an
            empty string as the routing key will be received). For more
            control the x-bindings element in the link properties must
            be used. A source address that resolves to the XML
            exchange must contain either a subject or an x-bindings
            element in the link properties as there is no way at
            present to receive any message regardless of routing key.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        If an x-bindings list is present in the link options a binding
        is created for each element within that list. Each element is
        a nested map that may contain values named queue, exchange,
        key or arguments. If the queue value is absent the queue name
        the address resolves to is implied. If the exchange value is
        absent the exchange name the address resolves to is implied.
      </para>

      <para>The following table shows how Qpid Messaging API message
        properties are mapped to AMQP 0-10 message properties and
        delivery properties. In this table <varname>msg</varname>
        refers to the Message class defined in the Qpid Messaging API,
        <varname>mp</varname> refers to an AMQP 0-10
        <varname>message-properties</varname> struct, and
        <varname>dp</varname> refers to an AMQP 0-10
        <varname>delivery-properties</varname> struct.</para>

      <table id="table-amqp0-10-message-properties" pgwide="1">
        <title>Mapping to AMQP 0-10 Message Properties</title>
        <tgroup cols="3">
          <thead>
	    <colspec colnum="1" colname="Python API" colwidth="3*"/>
	    <colspec colnum="2" colname="C++ API" colwidth="3*"/>
	    <colspec colnum="3" colname="AMPQ 0-10 Property" colwidth="6*"/>
	    <row>
	      <entry>Python API</entry>
	      <entry>C++ API</entry>
	      <entry>AMQP 0-10 Property<footnote><para>In these entries, <literal>mp</literal> refers to an AMQP message property, and <literal>dp</literal> refers to an AMQP delivery property.</para></footnote></entry>
	    </row>
          </thead>
          <tbody>
	    <row>
	      <entry>msg.id</entry><entry>msg.{get,set}MessageId()</entry><entry>mp.message_id</entry>
	    </row>
	    <row>
	      <entry>msg.subject</entry><entry>msg.{get,set}Subject()</entry><entry>mp.application_headers["qpid.subject"]</entry>
	    </row>
	    <row>
	      <entry>msg.user_id</entry><entry>msg.{get,set}UserId()</entry><entry>mp.user_id</entry>
	    </row>
	    <row>
	      <entry>msg.reply_to</entry><entry>msg.{get,set}ReplyTo()</entry><entry>mp.reply_to<footnote><para>The reply_to is converted from the protocol representation into an address.</para></footnote></entry>
	    </row>
	    <row>
	      <entry>msg.correlation_id</entry><entry>msg.{get,set}CorrelationId()</entry><entry>mp.correlation_id</entry>
	    </row>
	    <row>
	      <entry>msg.durable</entry><entry>msg.{get,set}Durable()</entry><entry>dp.delivery_mode == delivery_mode.persistent<footnote><para>Note that msg.durable is a boolean, not an enum.</para></footnote></entry>
	    </row>
	    <row>
	      <entry>msg.priority</entry><entry>msg.{get,set}Priority()</entry><entry>dp.priority</entry>
	    </row>
	    <row>
	      <entry>msg.ttl</entry><entry>msg.{get,set}Ttl()</entry><entry>dp.ttl</entry>
	    </row>
	    <row>
	      <entry>msg.redelivered</entry><entry>msg.{get,set}Redelivered()</entry><entry>dp.redelivered</entry>
	    </row>
	    <row><entry>msg.properties</entry><entry>msg.{get,set}Properties()</entry><entry>mp.application_headers</entry>
	    </row>
	    <row>
	      <entry>msg.content_type</entry><entry>msg.{get,set}ContentType()</entry><entry>mp.content_type</entry>
	    </row>
          </tbody>
        </tgroup>
      </table>
      
    </section>
  </chapter>


  <chapter id="QpidJMS">
    <title>Using the Qpid JMS client</title>
    <section>
      <title>A Simple Messaging Program in Java JMS</title>
      
      <para>The following program shows how to use address strings and
      JNDI for Qpid programs that use Java JMS.</para>

      <para>The Qpid JMS client uses Qpid Messaging API <xref
      linkend="section-addresses"/> to identify sources and
      targets. This program uses a JNDI properties file that defines a
      connection factory for the broker we are using, and the address
      of the topic exchange node that we bind the sender and receiver
      to. (The syntax of a ConnectionURL is given in <xref
      linkend="QpidJNDI"/>.)</para>

      <example>
	<title>JNDI Properties File for "Hello world!" example</title>
      <programlisting><![CDATA[
java.naming.factory.initial 
  = org.apache.qpid.jndi.PropertiesFileInitialContextFactory

# connectionfactory.[jndiname] = [ConnectionURL]
connectionfactory.qpidConnectionfactory 
  = amqp://guest:guest@clientid/test?brokerlist='tcp://localhost:5672'
# destination.[jndiname] = [address_string]
destination.topicExchange = amq.topic
]]></programlisting>
      </example>

      <para>In the Java JMS code, we use create a JNDI context, use the context to find a connection factory and create and start a connection, create a session, and create a destination that corresponds to the topic exchange. Then we create a sender and a receiver, send a message with the sender, and receive it with the receiver. This code should be straightforward for anyone familiar with Java JMS.</para>

      <example>
	<title>"Hello world!" in Java</title>
	<programlisting lang="java">
package org.apache.qpid.example.jmsexample.hello;

import javax.jms.*;
import javax.naming.Context;
import javax.naming.InitialContext;
import java.util.Properties;

public class Hello {

  public Hello() {
  }

  public static void main(String[] args) {
    Hello producer = new Hello();
    producer.runTest();
  }

  private void runTest() {
    try {
      Properties properties = new Properties();
      properties.load(this.getClass().getResourceAsStream("hello.properties"));  <co id="hello-java-properties" linkends="callout-java-properties"/>
      Context context = new InitialContext(properties);   <co id="hello-java-context" linkends="callout-java-context"/>

      ConnectionFactory connectionFactory 
          = (ConnectionFactory) context.lookup("qpidConnectionfactory"); <co id="hello-java-connection-factory" linkends="callout-java-connection-factory"/>
      Connection connection = connectionFactory.createConnection();  <co id="hello-java-connection" linkends="callout-java-connection"/>
      connection.start();  <co id="hello-java-start" linkends="callout-java-start"/>

      Session session=connection.createSession(false,Session.AUTO_ACKNOWLEDGE);<co id="hello-java-session" linkends="callout-java-session"/>
      Destination destination = (Destination) context.lookup("topicExchange");  <co id="hello-java-destination" linkends="callout-java-destination"/>

      MessageProducer messageProducer = session.createProducer(destination);  <co id="hello-java-producer" linkends="callout-java-producer"/>
      MessageConsumer messageConsumer = session.createConsumer(destination);  <co id="hello-java-consumer" linkends="callout-java-consumer"/>

      TextMessage message = session.createTextMessage("Hello world!");
      messageProducer.send(message);

      message = (TextMessage)messageConsumer.receive();    <co id="hello-java-receive" linkends="callout-java-receive"/>
      System.out.println(message.getText());

      connection.close();  <co id="hello-java-close" linkends="callout-java-close"/>
      context.close();   <co id="hello-java-jndi-close" linkends="callout-java-jndi-close"/>
    }
    catch (Exception exp) {
      exp.printStackTrace();
    }
  }
}
	</programlisting>
      </example>

      <calloutlist>
	<callout id="callout-java-properties" arearefs="hello-java-properties">
	  <para>Loads the JNDI properties file, which specifies connection properties, queues, topics, and addressing options. See <xref linkend="QpidJNDI"/> for details.</para>
	</callout>
	<callout id="callout-java-context" arearefs="hello-java-context">
	  <para>Creates the JNDI initial context.</para>
	</callout>
	<callout id="callout-java-connection-factory" arearefs="hello-java-connection-factory">
	  <para>Creates a JMS connection factory for Qpid.</para>
	</callout>
	<callout id="callout-java-connection" arearefs="hello-java-connection">
	  <para>Creates a JMS connection.</para>
	</callout>
	<callout id="callout-java-start" arearefs="hello-java-start">
	  <para>Activates the connection.</para>
	</callout>
	<callout id="callout-java-session" arearefs="hello-java-session">
	  <para>Creates a session. This session is not transactional (transactions='false'), and messages are automatically acknowledged.</para>
	</callout>
	<callout id="callout-java-destination" arearefs="hello-java-destination">
	  <para>Creates a destination for the topic exchange, so senders and receivers can use it.</para>
	</callout>
	<callout id="callout-java-producer" arearefs="hello-java-producer">
	  <para>Creates a producer that sends messages to the topic exchange.</para>
	</callout>
	<callout id="callout-java-consumer" arearefs="hello-java-consumer">
	  <para>Creates a consumer that reads messages from the topic exchange.</para>
	</callout>
	<callout id="callout-java-receive" arearefs="hello-java-receive">
	  <para>Reads the next available message.</para>
	</callout>
	<callout id="callout-java-close" arearefs="hello-java-close">
	  <para>Closes the connection, all sessions managed by the connection, and all senders and receivers managed by each session.</para>
	</callout>
	<callout id="callout-java-jndi-close" arearefs="hello-java-jndi-close">
	  <para>Closes the JNDI context.</para>
	</callout>
      </calloutlist>


    </section>

    <section id="QpidJNDI">
      <title>Apache Qpid JNDI Properties for AMQP Messaging</title>


      <para>
	Apache Qpid defines JNDI properties that can be used to specify JMS Connections and Destinations. Here is a typical JNDI properties file:
      </para>

      <example>
	<title>JNDI Properties File</title>
    <programlisting><![CDATA[
java.naming.factory.initial 
  = org.apache.qpid.jndi.PropertiesFileInitialContextFactory

# connectionfactory.[jndiname] = [ConnectionURL]
connectionfactory.qpidConnectionfactory 
  = amqp://guest:guest@clientid/test?brokerlist='tcp://localhost:5672'
# destination.[jndiname] = [address_string]
destination.topicExchange = amq.topic
]]></programlisting>
      </example>

      <para>The following sections describe the JNDI properties that Qpid uses.</para>

      
      <section>
        <title>JNDI Properties for Apache Qpid</title>
        <para>
	  Apache Qpid supports the properties shown in the following table:
        </para>
        <table>
	  <title>JNDI Properties supported by Apache Qpid</title>
	  <tgroup cols="2">
	    <thead>
	      <row>
	        <entry>
		  Property
	        </entry>
	        <entry>
		  Purpose
	        </entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
	        <entry>
		  connectionfactory.&lt;jndiname&gt;
	        </entry>
	        <entry>
		  <para>
		    The Connection URL that the connection factory uses to perform connections.
		  </para>
	        </entry>
	      </row>
	      <row>
	        <entry>
		  queue.&lt;jndiname&gt;
	        </entry>
	        <entry>
		  <para>
		    A JMS queue, which is implemented as an amq.direct exchange in Apache Qpid.
		  </para>
	        </entry>
	      </row>
	      <row>
	        <entry>
		  topic.&lt;jndiname&gt;
	        </entry>
	        <entry>
		  <para>
		    A JMS topic, which is implemented as an amq.topic exchange in Apache Qpid.
		  </para>
	        </entry>
	      </row>
	      <row>
	        <entry>
		  destination.&lt;jndiname&gt;
	        </entry>
	        <entry>
		  <para>
		    Can be used for defining all amq destinations,
		    queues, topics and header matching, using an
		    address string.  

		    <footnote><para>Binding URLs, which were used in
		    earlier versions of the Qpid Java JMS client, can
		    still be used instead of address
		    strings.</para></footnote>
		  </para>
	        </entry>
	      </row>
	    </tbody>
	  </tgroup>
        </table>
      </section>
      
      <section>
        <title>Connection URLs</title>
        <para>
	  In JNDI properties, a Connection URL specifies properties for a connection. The format for a Connection URL is:
        </para>
        
        <programlisting>amqp://[&lt;user&gt;:&lt;pass&gt;@][&lt;clientid&gt;]&lt;virtualhost&gt;[?&lt;option&gt;=&#39;&lt;value&gt;&#39;[&amp;&lt;option&gt;=&#39;&lt;value&gt;&#39;]]
        </programlisting>
        <para>
	  For instance, the following Connection URL specifies a user name, a password, a client ID, a virtual host ("test"), a broker list with a single broker, and a TCP host with the host name <quote>localhost</quote> using port 5672:
        </para>
        
        <programlisting>amqp://username:password@clientid/test?brokerlist=&#39;tcp://localhost:5672&#39;
        </programlisting>
        <para>
	  Apache Qpid supports the following properties in Connection URLs:
        </para>
        <table pgwide="1">
	  <title>Connection URL Properties</title>
	  <tgroup cols="3">
	    <thead>
	      <row>
	        <entry>
		  Option
	        </entry>
	        <entry>
		  Type
	        </entry>
	        <entry>
		  Description
	        </entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
	        <entry>
		  brokerlist
	        </entry>
	        <entry>
		  see below
	        </entry>
	        <entry>
		  The broker to use for this connection. In the current release, precisely one broker must be specified.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  maxprefetch
	        </entry>
	        <entry>
		  --
	        </entry>
	        <entry>
		  The maximum number of pre-fetched messages per destination.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  sync_publish
	        </entry>
	        <entry>
           {'persistent' | 'all'}
	        </entry>
	        <entry>
          A sync command is sent after every persistent message to guarantee that it has been received; if the value is 'persistent', this is done only for persistent messages.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  sync_ack
	        </entry>
	        <entry>
           Boolean
	        </entry>
	        <entry>
          A sync command is sent after every acknowledgement to guarantee that it has been received.
	        </entry>
	      </row>
          <row>
	        <entry>
		  use_legacy_map_msg_format
	        </entry>
	        <entry>
          Boolean
	        </entry>
	        <entry>
          If you are using JMS Map messages and deploying a new client with any JMS client older than 0.7 release, you must set this to true to ensure the older clients can understand the map message encoding.
	        </entry>
	      </row>
          <row>
	        <entry>
		  failover
	        </entry>
	        <entry>
           {'roundrobin' | 'failover_exchange'}
	        </entry>
	        <entry>
          If roundrobin is selected it will try each broker given in the broker list.
          If failover_exchange is selected it connects to the initial broker given in the broker URL and will receive membership updates via the failover exchange.
	        </entry>
	      </row>
	    </tbody>
	  </tgroup>
        </table>
        <para>
	  Broker lists are specified using a URL in this format:
        </para>
        
        <programlisting>brokerlist=&lt;transport&gt;://&lt;host&gt;[:&lt;port&gt;](?&lt;param>=&lt;value>)?(&amp;&lt;param>=&lt;value>)*</programlisting>
        <para>
	  For instance, this is a typical broker list:
        </para>
        
        <programlisting>brokerlist=&#39;tcp://localhost:5672&#39;
        </programlisting>

	<para>
	  A broker list can contain more than one broker address; if so, the connection is made to the first broker in the list that is available. In general, it is better to use the failover exchange when using multiple brokers, since it allows applications to fail over if a broker goes down.
	</para>

	<example>
	  <title>Broker Lists</title>
	<para>A broker list can specify properties to be used when connecting to the broker, such as security options. This broker list specifies options for a Kerberos connection using GSSAPI:</para>
	<programlisting><![CDATA[
amqp://guest:guest@test/test?sync_ack='true'
    &brokerlist='tcp://ip1:5672?sasl_mechs='GSSAPI'
	]]></programlisting>

	<para>This broker list specifies SSL options:</para>

	<programlisting><![CDATA[
amqp://guest:guest@test/test?sync_ack='true'
   &brokerlist='tcp://ip1:5672?ssl='true'&ssl_cert_alias='cert1'
	]]></programlisting>
	</example>

	<para>The following broker list options are supported.</para>

        <table pgwide="1">
	  <title>Broker List Options</title>
	  <tgroup cols="3">
	    <thead>
	      <row>
	        <entry>
		  Option
	        </entry>
	        <entry>
		  Type
	        </entry>
	        <entry>
		  Description
	        </entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
	        <entry>
		  heartbeat
	        </entry>
	        <entry>
		  integer
	        </entry>
	        <entry>
		  frequency of heartbeat messages (in seconds)
	        </entry>
	      </row>
	      <row>
	        <entry>
		  sasl_mechs
	        </entry>
	        <entry>
		  --
	        </entry>
	        <entry>
		  For secure applications, we suggest CRAM-MD5,
		  DIGEST-MD5, or GSSAPI. The ANONYMOUS method is not
		  secure. The PLAIN method is secure only when used
		  together with SSL. For Kerberos, sasl_mechs must be
		  set to GSSAPI, sasl_protocol must be set to the
		  principal for the qpidd broker, e.g. qpidd/, and
		  sasl_server must be set to the host for the SASL
		  server, e.g. sasl.com.  SASL External is supported
		  using SSL certification, e.g.
		  <literal>ssl='true'&amp;sasl_mechs='EXTERNAL'</literal>
	        </entry>
	      </row>
	      <row>
	        <entry>
		  sasl_encryption
	        </entry>
	        <entry>
          Boolean  
	        </entry>
	        <entry>
          If <literal>sasl_encryption='true'</literal>, the JMS client attempts to negotiate a security layer with the broker using GSSAPI to encrypt the connection. Note that for this to happen, GSSAPI must be selected as the sasl_mech.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  ssl
	        </entry>
	        <entry>
		  Boolean
	        </entry>
	        <entry>
		  If <literal>ssl='true'</literal>, the JMS client will encrypt the connection using SSL.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  tcp_nodelay
	        </entry>
	        <entry>
		  Boolean
	        </entry>
	        <entry>
		  If <literal>tcp_nodelay='true'</literal>, TCP packet
		  batching is disabled.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  sasl_protocol
	        </entry>
	        <entry>
		  --
	        </entry>
	        <entry>
		  Used only for
		  Kerberos. <literal>sasl_protocol</literal> must be
		  set to the principal for the qpidd broker,
		  e.g. <literal>qpidd/</literal>
	        </entry>
	      </row>
	      <row>
	        <entry>
		  sasl_server
	        </entry>
	        <entry>
		  --
	        </entry>
	        <entry>
		  For Kerberos, sasl_mechs must be set to GSSAPI,
		  sasl_server must be set to the host for the SASL
		  server, e.g. <literal>sasl.com</literal>.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  trust_store
	        </entry>
	        <entry>
		  --
	        </entry>
	        <entry>
		  path to Keberos trust store
	        </entry>
	      </row>
	      <row>
	        <entry>
		  trust_store_password
	        </entry>
	        <entry>
	        </entry>
	        <entry>
		  Kerberos trust store password
	        </entry>
	      </row>
	      <row>
	        <entry>
		  key_store
	        </entry>
	        <entry>
	        </entry>
	        <entry>
		  path to Kerberos key store
	        </entry>
	      </row>
	      <row>
	        <entry>
		  key_store_password
	        </entry>
	        <entry>
		  --
	        </entry>
	        <entry>
		  Kerberos key store password
	        </entry>
	      </row>
	      <row>
	        <entry>
		  ssl_verify_hostname
	        </entry>
	        <entry>
		  Boolean
	        </entry>
	        <entry>
		  When using SSL you can enable hostname verification
		  by using "ssl_verify_hostname=true" in the broker
		  URL.
	        </entry>
	      </row>
	      <row>
	        <entry>
		  ssl_cert_alias
	        </entry>
	        <entry>

	        </entry>
	        <entry>
          If multiple certificates are present in the keystore, the alias will be used to extract the correct certificate.
	        </entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </section>
    </section>  

    <section>
      <title>Java JMS Message Properties</title>

      <para>The following table shows how Qpid Messaging API message
        properties are mapped to AMQP 0-10 message properties and
        delivery properties. In this table <varname>msg</varname>
        refers to the Message class defined in the Qpid Messaging API,
        <varname>mp</varname> refers to an AMQP 0-10
        <varname>message-properties</varname> struct, and
        <varname>dp</varname> refers to an AMQP 0-10
        <varname>delivery-properties</varname> struct.</para>

      <table >
        <title>Java JMS Mapping to AMQP 0-10 Message Properties</title>
        <tgroup cols="2">
          <thead>
	    <row>
	      <entry>Java JMS Message Property</entry>
	      <entry>AMQP 0-10 Property<footnote><para>In these entries, <literal>mp</literal> refers to an AMQP message property, and <literal>dp</literal> refers to an AMQP delivery property.</para></footnote></entry>

	    </row>
          </thead>
          <tbody>
	    <row>
	      <entry>JMSMessageID</entry><entry>mp.message_id</entry>
	    </row>
	    <row>
	      <entry>qpid.subject<footnote><para>This is a custom JMS property, set automatically by the Java JMS client implementation.</para></footnote></entry><entry>mp.application_headers["qpid.subject"]</entry>
	    </row>
	    <row>
	      <entry>JMSXUserID</entry><entry>mp.user_id</entry>
	    </row>
	    <row>
	      <entry>JMSReplyTo</entry><entry>mp.reply_to<footnote><para>The reply_to is converted from the protocol representation into an address.</para></footnote></entry>
	    </row>
	    <row>
	      <entry>JMSCorrelationID</entry><entry>mp.correlation_id</entry>
	    </row>
	    <row>
	      <entry>JMSDeliveryMode</entry><entry>dp.delivery_mode</entry>
	    </row>
	    <row>
	      <entry>JMSPriority</entry><entry>dp.priority</entry>
	    </row>
	    <row>
	      <entry>JMSExpiration</entry><entry>dp.ttl<footnote><para>JMSExpiration = dp.ttl + currentTime</para></footnote></entry>
	    </row>
	    <row>
	      <entry>JMSRedelivered</entry><entry>dp.redelivered</entry>
	    </row>
	    <row>
	      <entry>JMS Properties</entry><entry>mp.application_headers</entry>
	    </row>
	    <row>
	      <entry>JMSType</entry><entry>mp.content_type</entry>
	    </row>
          </tbody>
        </tgroup>
      </table>
      
    </section>

    <section id="section-JMS-MapMessage">
      <title>JMS MapMessage Types</title>

      <para>Qpid supports the Java JMS <classname>MapMessage</classname> interface, which provides support for maps in messages. The following code shows how to send a <classname>MapMessage</classname> in Java JMS.</para>

      <example>
	<title>Sending a Java JMS MapMessage</title>
      <programlisting><![CDATA[
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.jms.Connection;
import javax.jms.Destination;
import javax.jms.MapMessage;
import javax.jms.MessageProducer;
import javax.jms.Session;

import org.apache.qpid.client.AMQAnyDestination;
import org.apache.qpid.client.AMQConnection;

import edu.emory.mathcs.backport.java.util.Arrays;

// !!! SNIP !!!

MessageProducer producer = session.createProducer(queue);

MapMessage m = session.createMapMessage();
m.setIntProperty("Id", 987654321);
m.setStringProperty("name", "Widget");
m.setDoubleProperty("price", 0.99);

List<String> colors = new ArrayList<String>();
colors.add("red");
colors.add("green");
colors.add("white");        
m.setObject("colours", colors);

Map<String,Double> dimensions = new HashMap<String,Double>();
dimensions.put("length",10.2);
dimensions.put("width",5.1);
dimensions.put("depth",2.0);
m.setObject("dimensions",dimensions);

List<List<Integer>> parts = new ArrayList<List<Integer>>();
parts.add(Arrays.asList(new Integer[] {1,2,5}));
parts.add(Arrays.asList(new Integer[] {8,2,5}));
m.setObject("parts", parts);

Map<String,Object> specs = new HashMap<String,Object>();
specs.put("colours", colors);
specs.put("dimensions", dimensions);
specs.put("parts", parts);
m.setObject("specs",specs);

producer.send(m);
      ]]></programlisting>
      </example>

      <para>The following table shows the datatypes that can be sent in a <classname>MapMessage</classname>, and the corresponding datatypes that will be received by clients in Python or C++.</para>
      
      <table id="table-Java-Maps">
	<title>Java Datatypes in Maps</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Java Datatype</entry>
	      <entry>&rarr; Python</entry>
	      <entry>&rarr; C++</entry>
	    </row>
	  </thead>
	  <tbody>
   	    <row><entry>boolean</entry><entry>bool</entry><entry>bool</entry></row>
	    <row><entry>short</entry><entry>int | long</entry><entry>int16</entry></row>
	    <row><entry>int</entry><entry>int | long</entry><entry>int32</entry></row>
	    <row><entry>long</entry><entry>int | long</entry><entry>int64</entry></row>
	    <row><entry>float</entry><entry>float</entry><entry>float</entry></row>
	    <row><entry>double</entry><entry>float</entry><entry>double</entry></row>
	    <row><entry>java.lang.String</entry><entry>unicode</entry><entry>std::string</entry></row>
	    <row><entry>java.util.UUID</entry><entry>uuid</entry><entry>qpid::types::Uuid</entry></row>
	    <row><entry>java.util.Map<footnote><para>In Qpid, maps can nest. This goes beyond the functionality required by the JMS specification.</para></footnote></entry><entry>dict</entry><entry>Variant::Map</entry></row>
	    <row><entry>java.util.List</entry><entry>list</entry><entry>Variant::List</entry></row>
	  </tbody>
	</tgroup>
      </table>

    </section>
    
    <section id="section-JMS-Loggin">
      <title>JMS Client Loggin</title>
      <para>The JMS Client logging is handled using <ulink url="http://www.slf4j.org/">SLF4J</ulink>. A user can place a slf4j binding of their choice in the classpath and configure the respective logging mechanism to suit their needs. Ex bindings include log4j, jdk1.4 logging ..etc</para>

      <para>Following is an example on how to configure the client logging with the log4j binding.</para>

      <para>For more information on how to configure log4j, please consult the log4j documentation.</para>

      <para>If using the log4j binding please ensure to set the log level for org.apache.qpid explicitly. Otherwise log4j will default to DEBUG which will degrade performance considerably due to excessive logging. Recommended logging level for production is WARN.</para>

      <example>
      <para>You could place the snippet below in a log4j.properties file and place it in the classpath or explicitly specify it using the -Dlog4j.configuration property. The following configures the qpid client to log at the WARN level</para>
      <programlisting><![CDATA[
log4j.logger.org.apache.qpid=WARN, console
log4j.additivity.org.apache.qpid=false

log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.Threshold=all
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%t %d %p [%c{4}] %m%n
      ]]></programlisting>
      </example> 
    </section>
  </chapter>

  <chapter id="QpidWCF">
    <title>Using the Qpid WCF client</title>
    <section>
      <title>XML and Binary Bindings</title>

      <para>The Qpid WCF client provides two bindings, each with support for
      Windows .NET transactions.</para>

      <para>The AmqpBinding is suitable for communication between two WCF
      applications.  By default it uses the WCF binary .NET XML encoder
      (BinaryMessageEncodingBindingElement) for efficient message
      transmission, but it can also use the text and Message Transmission
      Optimization Mechanism (MTOM) encoders.  Here is a traditional service
      model sample program using the AmqpBinding.  It assumes that the queue
      "hello_service_node" has been created and configured on the AMQP
      broker.</para>

      <example>
	<title>Traditional service model "Hello world!" example</title>
	<programlisting><![CDATA[
namespace Apache.Qpid.Documentation.HelloService
{
  using System;
  using System.ServiceModel;
  using System.ServiceModel.Channels;
  using System.Threading;
  using Apache.Qpid.Channel;

  [ServiceContract]
  public interface IHelloService
  {
    [OperationContract(IsOneWay = true, Action = "*")]
    void SayHello(string greeting);
  }

  public class HelloService : IHelloService
  {
    private static int greetingCount;

    public static int GreetingCount
    {
      get { return greetingCount; }
    }

    public void SayHello(string greeting)
    {
      Console.WriteLine("Service received: " + greeting);
      greetingCount++;
    }]]></programlisting>

    <programlisting><![CDATA[
    static void Main(string[] args)
    {
      try
      {
        AmqpBinding amqpBinding = new AmqpBinding();
        amqpBinding.BrokerHost = "localhost";
        amqpBinding.BrokerPort = 5672;

        ServiceHost serviceHost = new ServiceHost(typeof(HelloService));
        serviceHost.AddServiceEndpoint(typeof(IHelloService),
          amqpBinding, "amqp:hello_service_node");
        serviceHost.Open();

        // Send the service a test greeting
        Uri amqpClientUri=new Uri("amqp:amq.direct?routingkey=hello_service_node");
        EndpointAddress clientEndpoint = new EndpointAddress(amqpClientUri);
        ChannelFactory<IHelloService> channelFactory =
          new ChannelFactory<IHelloService>(amqpBinding, clientEndpoint);
        IHelloService clientProxy = channelFactory.CreateChannel();

        clientProxy.SayHello("Greetings from WCF client");

        // wait for service to process the greeting
        while (HelloService.GreetingCount == 0)
        {
          Thread.Sleep(100);
        }
        channelFactory.Close();
        serviceHost.Close();
      }
      catch (Exception e)
      {
        Console.WriteLine("Exception: {0}", e);
      }
    }
  }
}
      ]]></programlisting>
      </example>

      <para>The second binding, AmqpBinaryBinding, is suitable for WCF
      applications that need to inter-operate with non-WCF clients or that
      wish to have direct access to the raw wire representation of the
      message body.  It relies on a custom encoder to read and write raw
      (binary) content which operates similarly to the ByteStream encoder
      (introduced in .NET 4.0).  The encoder presents an abstract XML
      infoset view of the raw message content on input.  On output, the
      encoder does the reverse and peels away the XML infoset layer exposing
      the raw content to the wire representation of the message body.  The
      application must do the inverse of what the encoder does to allow the
      XML infoset wrapper to cancel properly.  This is demonstrated in the
      following sample code (using the channel programming model) which
      directly manipulates or provides callbacks to the WCF message readers
      and writers when the content is consumed.  In contrast to the
      AmqpBinding sample where the simple greeting is encapsulated in a
      compressed SOAP envelope, the wire representation of the message
      contains the raw content and is identical and fully interoperable with
      the Qpid C++ "Hello world!"  example.</para>

      <example>
	<title>Binary  "Hello world!" example using the channel model</title>
	<programlisting><![CDATA[
namespace Apache.Qpid.Samples.Channel.HelloWorld
{
  using System;
  using System.ServiceModel;
  using System.ServiceModel.Channels;
  using System.ServiceModel.Description;
  using System.Text;
  using System.Xml;
  using Apache.Qpid.Channel;

  public class HelloWorld
  {  
    static void Main(string[] args)
    {
      String broker = "localhost";
      int port = 5672;
      String target = "amq.topic";
      String source = "my_topic_node";

      if (args.Length > 0)
      {
        broker = args[0];
      }

      if (args.Length > 1)
      {
        port = int.Parse(args[1]);
      }

      if (args.Length > 2)
      {
        target = args[2];
      }

      if (args.Length > 3)
      {
        source = args[3];
      }

      AmqpBinaryBinding binding = new AmqpBinaryBinding();
      binding.BrokerHost = broker;
      binding.BrokerPort = port;

      IChannelFactory<IInputChannel> receiverFactory = binding.BuildChannelFactory<IInputChannel>();
      receiverFactory.Open();
      IInputChannel receiver = receiverFactory.CreateChannel(new EndpointAddress("amqp:" + source));
      receiver.Open();

      IChannelFactory<IOutputChannel> senderFactory = binding.BuildChannelFactory<IOutputChannel>();
      senderFactory.Open();
      IOutputChannel sender = senderFactory.CreateChannel(new EndpointAddress("amqp:" + target));
      sender.Open();

      sender.Send(Message.CreateMessage(MessageVersion.None, "", new HelloWorldBinaryBodyWriter()));

      Message message = receiver.Receive();
      XmlDictionaryReader reader = message.GetReaderAtBodyContents();
      while (!reader.HasValue)
      {
        reader.Read();
      }

      byte[] binaryContent = reader.ReadContentAsBase64();
      string text = Encoding.UTF8.GetString(binaryContent);

      Console.WriteLine(text);

      senderFactory.Close();
      receiverFactory.Close();
    }
  }

  public class HelloWorldBinaryBodyWriter : BodyWriter
  {
    public HelloWorldBinaryBodyWriter() : base (true) {}

    protected override void OnWriteBodyContents(XmlDictionaryWriter writer)
    {
      byte[] binaryContent = Encoding.UTF8.GetBytes("Hello world!");

      // wrap the content:
      writer.WriteStartElement("Binary");
      writer.WriteBase64(binaryContent, 0, binaryContent.Length);
    }
  }
}
]]></programlisting>
      </example>

      <para>Bindings define ChannelFactories and ChannelListeners associated with
      an AMQP Broker.  WCF will frequently automatically create and manage
      the life cycle of a these and the resulting IChannel objects used in
      message transfer.  The binding parameters that can be set are:</para>

      <table pgwide="1">
        <title>WCF Binding Parameters</title>
        <tgroup cols="3">
          <thead>
	    <colspec colnum="1" colwidth="1*"/>
	    <colspec colnum="2" colwidth="3*"/>
	    <colspec colnum="3" colwidth="3*"/>
	    <row>
	      <entry>Parameter</entry>
	      <entry>Default</entry>
	      <entry>Description</entry>
	    </row>
          </thead>
          <tbody>
	    <row>
	      <entry>
		BrokerHost
	      </entry>
	      <entry>
		localhost
	      </entry>
	      <entry>
		The broker's server name.  Currently the WCF channel
		only supports connections with a single broker.
		Failover to multiple brokers will be provided in the
		future.
	      </entry>
	    </row>

	    <row>
	      <entry>
		BrokerPort
	      </entry>
	      <entry>
		5672
	      </entry>
	      <entry>
		The port the broker is listening on.
	      </entry>
	    </row>

	    <row>
	      <entry>
		PrefetchLimit
	      </entry>
	      <entry>
		0
	      </entry>
	      <entry>
		The number of messages to prefetch from the amqp
		broker before the application actually consumes them.
		Increasing this number can dramatically increase the
		read performance in some circumstances.
	      </entry>
	    </row>

	    <row>
	      <entry>
		Shared
	      </entry>
	      <entry>
		false
	      </entry>
	      <entry>
		Indicates if separate channels to the same broker can
		share an underlying AMQP tcp connection (provided they
		also share the same authentication credentials).
	      </entry>
	    </row>

	    <row>
	      <entry>
		TransferMode
	      </entry>
	      <entry>
		buffered
	      </entry>
	      <entry>
		Indicates whether the channel's encoder uses the WCF
		BufferManager cache to temporarily store message
		content during the encoding/decoding phase.  For small
		to medium sized SOAP based messages, buffered is
		usually the preferred choice.  For binary messages,
		streamed TransferMode is the more efficient mode.
	      </entry>
	    </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section>
      <title>Endpoints</title>

      <para>In Qpid 0.6 the WCF Endpoints map to simple AMQP 0-10
      exchanges (IOutputChannel) or AMQP 0-10 queues (IInputChannel).
      The format for an IOutputChannel is</para>

      <programlisting><![CDATA[
  "amqp:amq.direct" or "amqp:my_exchange?routingkey=my_routing_key"
]]></programlisting>

      <para>and for an IInputChannel is</para>

      <programlisting><![CDATA[
  "amqp:my_queue"
]]></programlisting>

      <para>The routing key is in fact a default value associated with
      the particular channel.  Outgoing messages can always have their
      routing key uniquely set.</para>

      <para>If the respective queue or exchange doesn't exist, an exception
      is thrown when opening the channel.  Queues and exchanges can be
      created and configured using qpid-config.</para>

    </section>

    <section>
      <title>Message Headers</title>

      <para>AMQP specific message headers can be set on or retrieved
      from the ServiceModel.Channels.Message using the AmqpProperties
      type.</para>

      <para>For example, on output:</para>

      <programlisting><![CDATA[
AmqpProperties props = new AmqpProperties();
props.Durable = true;
props.PropertyMap.Add("my_custom_header", new AmqpString("a custom value"));
Message msg = Message.CreateMessage(args);
msg.Properties.Add("AmqpProperties", amqpProperties);
outputChannel.Send(msg);
]]></programlisting>

      <para>On input the headers can be accessed from the Message or extracted
      from the operation context</para>

      <programlisting><![CDATA[
public void SayHello(string greeting)
{
  AmqpProperties props = (AmqpProperties) OperationContext.
  Current.IncomingMessageProperties["AmqpProperties"];
  AmqpString extra = (AmqpString) props.PropertyMap["my_custom_header"];
  Console.WriteLine("Service received: {0} and {1}", greeting, extra);
}
]]></programlisting>

    </section>

    <section>
      <title>Security</title>

      <para>To engage TLS/SSL:</para>

      <programlisting><![CDATA[
binding.Security.Mode = AmqpSecurityMode.Transport;
binding.Security.Transport.UseSSL = true;
binding.BrokerPort = 5671;
]]></programlisting>

      <para>Currently the WCF client only provides SASL PLAIN (i.e. username and
      password) authentication.  To provide a username and password, you can
      set the DefaultAmqpCredential value in the binding.  This value can be
      overridden or set for a binding's channel factories and listeners,
      either by setting the ClientCredentials as a binding parameter, or by
      using an AmqpCredential as a binding parameter.  The search order for
      credentials is the AmqpCredential binding parameter, followed by the
      ClientCredentials (unless IgnoreEndpointClientCredentials has been
      set), and finally defaulting to the DefaultAmqpCredential of the
      binding itself.  Here is a sample using ClientCredentials:</para>

      <programlisting><![CDATA[
ClientCredentials credentials = new ClientCredentials();
credentials.UserName.UserName = "guest";
credentials.UserName.Password = "guest";
bindingParameters = new BindingParameterCollection();
bindingParameters.Add(credentials);
readerFactory = binding.BuildChannelFactory<IInputChannel>(bindingParameters);
]]></programlisting>

    </section>

    <section>
      <title>Transactions</title>

      <para>The WCF channel provides a transaction resource manager
      module and a recovery module that together provide distributed
      transaction support with one-phase optimization.  Some
      configuration is required on Windows machines to enable
      transaction support (see your installation notes or top level
      ReadMe.txt file for instructions).  Once properly configured,
      the Qpid WCF channel acts as any other System.Transactions aware
      resource, capable of participating in explicit or implicit
      transactions.</para>

      <para>Server code:</para>

      <programlisting><![CDATA[
[OperationBehavior(TransactionScopeRequired = true,
                   TransactionAutoComplete = true)]

public void SayHello(string greeting)
{
  // increment ExactlyOnceReceived counter on DB

  // Success: transaction auto completes:
}
]]></programlisting>

      <para>Because this operation involves two transaction resources, the
      database and the AMQP message broker, this operates as a full two
      phase commit transaction managed by the Distributed Transaction
      Coordinator service.  If the transaction proceeds without error,
      both ExactlyOnceReceived is incremented in the database and the AMQP
      message is consumed from the broker.  Otherwise, ExactlyOnceReceived is
      unchanged and AMQP message is returned to its queue on the broker.</para>

      <para>For the client code a few changes are made to the non-transacted
      example.  For "exactly once" semantics, we set the AMQP "Durable"
      message property and enclose the transacted activities in a
      TransactionScope:</para>

      <programlisting><![CDATA[
AmqpProperties myDefaults = new AmqpProperties();
myDefaults.Durable = true;
amqpBinding.DefaultMessageProperties = myDefaults;
ChannelFactory<IHelloService> channelFactory =
new ChannelFactory<IHelloService>(amqpBinding, clientEndpoint);
IHelloService clientProxy = channelFactory.CreateChannel();

using (TransactionScope ts = new TransactionScope())
{
   AmqpProperties amqpProperties = new AmqpProperties();
   clientProxy.SayHello("Greetings from WCF client");
   // increment ExactlyOnceSent counter on DB
   ts.Complete();
}
]]></programlisting>

    </section>
  </chapter>

</book>

<!--
   - client code remains exactly the same, but routing behavior
   changes
   - exchanges drop messages if nobody is listening, so we need to
   start drain first
   - drain will exit immediately if the source is empty (note that
   this is actually a semantic guarantee provided by the API, we
   know for a fact that the source is empty when drain/fetch
   reports it, no fudge factor timeout is required [this assumes
   nobody is concurrently publishing of course])
   - drain -f invokes blocking fetch (you could use a timeout here also)
  -->
